C251 COMPILER V5.60.0,  key                                                                22/11/25  23:09:30  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE key
OBJECT MODULE PLACED IN .\out_file\key.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\key.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BR
                    -OWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;
                    -..\user;..\code) DEBUG PRINT(.\out_file\key.lst) OBJECT(.\out_file\key.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          
    3          // 定义按键引脚
    4          #define KEY1_PIN P33 // 上键
    5          #define KEY2_PIN P34 // 下键
    6          #define KEY3_PIN P36 // 确定键
    7          #define KEY4_PIN P37 // 返回键
    8          // 长按时间阈值(单位：次数，取决于调用扫描函数的频率)
    9          #define LONG_PRESS_THRESHOLD 200
   10          
   11          uint8 keystroke_label = 0;      // 按下的是哪个键（0=无按键，1-4=短按，5-8=长按）
   12          uint8 key_last_status[4] = {0}; // 上一次按键状态
   13          uint8 key_status[4] = {0};      // 当前按键状态
   14          uint8 key_flag[4] = {0};        // 按键标志位
   15          uint16 key_press_time[4] = {0}; // 按键按下持续时间计数
   16          
   17          /**
   18           * @brief 按键扫描函数
   19           * @details 读取4个按键的状态，判断短按和长按
   20           * @note 需要定期调用以实现按键检测
   21           */
   22          void Keystroke_Scan(void)
   23          {
   24   1          uint8 i = 0;
   25   1          keystroke_label = 0; // 重置按键标识
   26   1      
   27   1          // 保存上一次按键状态
   28   1          for (i = 0; i < 4; i++)
   29   1          {
   30   2              key_last_status[i] = key_status[i];
   31   2          }
   32   1      
   33   1          // 读取当前按键状态（按键按下为低电平(0)，取反使按下状态在程序中用1表示）
   34   1          key_status[0] = !KEY1_PIN; // 上键状态，按下则值为1
   35   1          key_status[1] = !KEY2_PIN; // 下键状态，按下则值为1
   36   1          key_status[2] = !KEY3_PIN; // 确定键状态，按下则值为1
   37   1          key_status[3] = !KEY4_PIN; // 返回键状态，按下则值为1
   38   1      
   39   1          // 逐个检测按键状态变化
   40   1          for (i = 0; i < 4; i++)
   41   1          {
   42   2              if (key_status[i]) // 按键被按下
   43   2              {
   44   3                  if (!key_last_status[i]) // 按键刚刚按下（上升沿）
   45   3                  {
   46   4                      key_press_time[i] = 0; // 重置计数器
   47   4                  }
   48   3                  else // 按键持续按下
   49   3                  {
   50   4                      key_press_time[i]++;
   51   4      
   52   4                      // 检测长按阈值
   53   4                      if (key_press_time[i] == LONG_PRESS_THRESHOLD)
   54   4                      {
   55   5                          keystroke_label = i + 5; // 长按对应值为5-8
   56   5                          break;                   // 检测到长按后立即退出循环
   57   5                      }
C251 COMPILER V5.60.0,  key                                                                22/11/25  23:09:30  PAGE 2   

   58   4                  }
   59   3              }
   60   2              else // 按键未按下
   61   2              {
   62   3                  // 如果按键释放且之前状态为按下，且未达到长按阈值，则为短按
   63   3                  if (key_last_status[i] && key_press_time[i] < LONG_PRESS_THRESHOLD)
   64   3                  {
   65   4                      keystroke_label = i + 1; // 短按对应值为1-4
   66   4                      break;                   // 检测到短按后立即退出循环
   67   4                  }
   68   3                  key_press_time[i] = 0; // 重置计数器
   69   3              }
   70   2          }
   71   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       440     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        22     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        46     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
