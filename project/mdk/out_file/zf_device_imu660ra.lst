C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu660ra
OBJECT MODULE PLACED IN .\out_file\zf_device_imu660ra.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu660ra.c LARGE NOALIAS FLOAT64 W
                    -ARNINGLEVEL(3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf
                    -_device;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu660ra.lst) TABS(2) OBJECT(.\out_f
                    -ile\zf_device_imu660ra.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * AI8051U Opensource Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3           * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4           *
    5           * ±¾ÎÄ¼þÊÇ STC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6           *
    7           * AI8051U ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8           * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNU Í¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9           * ¼´ GPL µÄµÚ 3 °æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10           *
   11           * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎ±£Ö¤
   12           * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13           * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14           *
   15           * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16           * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ <https://www.gnu.org/licenses/>
   17           *
   18           * ¶îÍâ×¢Ã÷£º
   19           * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20           * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21           * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22           * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23           *
   24           * ÎÄ¼þÃû³Æ
   25           * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26           * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27           * ¿ª·¢»·¾³          MDK FOR C251
   28           * ÊÊÓÃÆ½Ì¨          AI8051U
   29           * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30           *
   31           * ÐÞ¸Ä¼ÇÂ¼
   32           * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33           * 2024-08-01        ´óW            first version
   34           ********************************************************************************************************
             -************/
   35          /********************************************************************************************************
             -*************
   36           * ½ÓÏß¶¨Òå£º
   37           *                   ------------------------------------
   38           *                   Ä£¿é¹Ü½Å            µ¥Æ¬»ú¹Ü??
   39           *                   // Ó²¼þ SPI Òý½Å
   40           *                   SCL/SPC           ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_SPC_PIN ºê¶¨Òå
   41           *                   SDA/DSI           ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_SDI_PIN ºê¶¨Òå
   42           *                   SA0/SDO           ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_SDO_PIN ºê¶¨Òå
   43           *                   CS                ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_CS_PIN ºê¶¨Òå
   44           *                   VCC               3.3VµçÔ´
   45           *                   GND               µçÔ´µØ
   46           *                   ÆäÓàÒý½ÅÐü¿Õ
   47           *
   48           *                   // Èí¼þ IIC Òý½Å
   49           *                   SCL/SPC           ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_SCL_PIN ºê¶¨Òå
   50           *                   SDA/DSI           ²é¿´ zf_device_imu660ra.h ÖÐ IMU660RA_SDA_PIN ºê¶¨Òå
   51           *                   VCC               3.3VµçÔ´
   52           *                   GND               µçÔ´µØ
   53           *                   ÆäÓàÒý½ÅÐü¿Õ
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 2   

   54           *                   ------------------------------------
   55           ********************************************************************************************************
             -************/
   56          
   57          #include "zf_common_debug.h"
   58          #include "zf_driver_delay.h"
   59          #include "zf_driver_spi.h"
   60          #include "zf_driver_gpio.h"
   61          #include "zf_driver_soft_iic.h"
   62          #include "zf_device_config.h"
   63          
   64          #include "zf_device_imu660ra.h"
   65          
   66          #pragma warning disable = 183
   67          #pragma warning disable = 177
   68          
   69          int16 imu660ra_gyro_x = 0, imu660ra_gyro_y = 0, imu660ra_gyro_z = 0; // ÈýÖáÍÓÂÝÒÇÊý¾Ý   gyro (ÍÓÂÝÒÇ)
   70          int16 imu660ra_acc_x = 0, imu660ra_acc_y = 0, imu660ra_acc_z = 0;    // ÈýÖá¼ÓËÙ¶È¼ÆÊý?? acc  (accelerome
             -ter ¼ÓËÙ¶È??)
   71          float imu660ra_transition_factor[2] = {4096, 16.4};
   72          
   73          #if IMU660RA_USE_SOFT_IIC
               static soft_iic_info_struct imu660ra_iic_struct;
               
               #define imu660ra_write_register(reg, dat) (soft_iic_write_8bit_register(&imu660ra_iic_struct, (reg), (dat
             -)))
               #define imu660ra_write_registers(reg, dat, len) (soft_iic_write_8bit_registers(&imu660ra_iic_struct, (reg
             -), (dat), (len)))
               #define imu660ra_read_register(reg) (soft_iic_read_8bit_register(&imu660ra_iic_struct, (reg)))
               #define imu660ra_read_registers(reg, dat, len) (soft_iic_read_8bit_registers(&imu660ra_iic_struct, (reg),
             - (dat), (len)))
               #else
   81          //-------------------------------------------------------------------------------------------------------
             -------------
   82          // º¯Êý¼ò½é     IMU660RA Ð´¼Ä´æÆ÷
   83          // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
   84          // ²ÎÊýËµÃ÷     dat             Êý¾Ý
   85          // ·µ»Ø²ÎÊý     void
   86          // Ê¹ÓÃÊ¾Àý     imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
   87          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
   88          //-------------------------------------------------------------------------------------------------------
             -------------
   89          static void imu660ra_write_register(uint8 reg, uint8 dat)
   90          {
   91   1          IMU660RA_CS(0);
   92   1          spi_write_8bit_register(IMU660RA_SPI, reg | IMU660RA_SPI_W, dat);
   93   1          IMU660RA_CS(1);
   94   1      }
   95          
   96          //-------------------------------------------------------------------------------------------------------
             -------------
   97          // º¯Êý¼ò½é     IMU660RA Ð´Êý¾Ý
   98          // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
   99          // ²ÎÊýËµÃ÷     dat             Êý¾Ý
  100          // ·µ»Ø²ÎÊý     void
  101          // Ê¹ÓÃÊ¾Àý     imu660ra_write_registers(IMU660RA_INIT_DATA, imu660ra_config_file, sizeof(imu660ra_config
             -_file));
  102          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  103          //-------------------------------------------------------------------------------------------------------
             -------------
  104          static void imu660ra_write_registers(uint8 reg, const uint8 *dat, uint32 len)
  105          {
  106   1          IMU660RA_CS(0);
  107   1          spi_write_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_W, dat, len);
  108   1          IMU660RA_CS(1);
  109   1      }
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 3   

  110          
  111          //-------------------------------------------------------------------------------------------------------
             -------------
  112          // º¯Êý¼ò½é     IMU660RA ¶Á¼Ä´æÆ÷
  113          // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  114          // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
  115          // Ê¹ÓÃÊ¾Àý     imu660ra_read_register(IMU660RA_CHIP_ID);
  116          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  117          //-------------------------------------------------------------------------------------------------------
             -------------
  118          static uint8 imu660ra_read_register(uint8 reg)
  119          {
  120   1          uint8 dat[2];
  121   1          IMU660RA_CS(0);
  122   1          spi_read_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_R, dat, 2);
  123   1          IMU660RA_CS(1);
  124   1          return dat[1];
  125   1      }
  126          
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          // º¯Êý¼ò½é     IMU660RA ¶ÁÊý¾Ý
  129          // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  130          // ²ÎÊýËµÃ÷     dat             Êý¾Ý»º³åÇø
  131          // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
  132          // ·µ»Ø²ÎÊý     void
  133          // Ê¹ÓÃÊ¾Àý     imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
  134          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  135          //-------------------------------------------------------------------------------------------------------
             -------------
  136          static void imu660ra_read_registers(uint8 reg, uint8 *dat, uint32 len)
  137          {
  138   1          uint16 i = 0;
  139   1          uint8 temp_data[8];
  140   1          IMU660RA_CS(0);
  141   1          spi_read_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_R, temp_data, len + 1);
  142   1          IMU660RA_CS(1);
  143   1      
  144   1          for (i = 0; i < len; i++)
  145   1          {
  146   2              *(dat++) = temp_data[i + 1];
  147   2          }
  148   1      }
  149          #endif
  150          
  151          //-------------------------------------------------------------------------------------------------------
             -------------
  152          // º¯Êý¼ò½é     IMU660RA ×Ô¼ì
  153          // ²ÎÊýËµÃ÷     void
  154          // ·µ»Ø²ÎÊý     uint8           1-×Ô¼ìÊ§°Ü 0-×Ô¼ì³É¹¦
  155          // Ê¹ÓÃÊ¾Àý     imu660ra_self_check();
  156          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  157          //-------------------------------------------------------------------------------------------------------
             -------------
  158          static uint8 imu660ra_self_check(void)
  159          {
  160   1          uint8 dat = 0, return_state = 0;
  161   1          uint16 timeout_count = 0;
  162   1      
  163   1          do
  164   1          {
  165   2              if (timeout_count++ > IMU660RA_TIMEOUT_COUNT)
  166   2              {
  167   3                  return_state = 1;
  168   3                  break;
  169   3              }
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 4   

  170   2      
  171   2              dat = imu660ra_read_register(IMU660RA_CHIP_ID);
  172   2              printf("imu660ra_read_register = 0x%X\r\n", dat);
  173   2              system_delay_ms(1);
  174   2          } while (0x24 != dat); // ¶ÁÈ¡Éè±¸ ID ÊÇ·ñµÈÓÚ 0x24£¬Èç¹û²»µÈÓÚ 0x24 ÔòÈÏÎªÃ»¼ì²âµ½Éè±¸
  175   1      
  176   1          return return_state;
  177   1      }
  178          
  179          //-------------------------------------------------------------------------------------------------------
             -------------
  180          // º¯Êý¼ò½é     »ñÈ¡ IMU660RA ¼ÓËÙ¶È¼ÆÊý¾Ý
  181          // ²ÎÊýËµÃ÷     void
  182          // ·µ»Ø²ÎÊý     void
  183          // Ê¹ÓÃÊ¾Àý     imu660ra_get_acc();                                             // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  184          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  185          //            Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us        ²É¼¯¼ÓËÙ¶È¼ÆµÄÊ±¼äÓë²É¼¯ÍÓÂÝÒÇµÄÊ±¼äÒ»ÖÂ£¬Ô­ÒòÊÇ¶¼Ö»ÊÇ¶ÁÈ
             -¡¼Ä´æÆ÷Êý¾Ý
  186          //-------------------------------------------------------------------------------------------------------
             -------------
  187          void imu660ra_get_acc(void)
  188          {
  189   1          uint8 dat[6];
  190   1      
  191   1          imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
  192   1          imu660ra_acc_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  193   1          imu660ra_acc_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  194   1          imu660ra_acc_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  195   1      }
  196          //-------------------------------------------------------------------------------------------------------
             -------------
  197          // º¯Êý¼ò½é     »ñÈ¡ IMU660RA ÍÓÂÝÒÇÊý¾Ý
  198          // ²ÎÊýËµÃ÷     void
  199          // ·µ»Ø²ÎÊý     void
  200          // Ê¹ÓÃÊ¾Àý     imu660ra_get_gyro();                                            // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  201          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  202          //            Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us
  203          //-------------------------------------------------------------------------------------------------------
             -------------
  204          void imu660ra_get_gyro(void)
  205          {
  206   1          uint8 dat[6];
  207   1      
  208   1          imu660ra_read_registers(IMU660RA_GYRO_ADDRESS, dat, 6);
  209   1          imu660ra_gyro_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  210   1          imu660ra_gyro_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  211   1          imu660ra_gyro_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  212   1      }
  213          
  214          //-------------------------------------------------------------------------------------------------------
             -------------
  215          // º¯Êý¼ò½é     ³õÊ¼»¯ IMU660RA
  216          // ²ÎÊýËµÃ÷     void
  217          // ·µ»Ø²ÎÊý     uint8           1-³õÊ¼»¯Ê§°Ü 0-³õÊ¼»¯³É¹¦
  218          // Ê¹ÓÃÊ¾Àý     imu660ra_init();
  219          // ±¸×¢ÐÅÏ¢
  220          //-------------------------------------------------------------------------------------------------------
             -------------
  221          uint8 imu660ra_init(void)
  222          {
  223   1          uint8 return_state = 0;
  224   1          system_delay_ms(20); // µÈ´ýÉè±¸ÉÏµç³É¹¦
  225   1      
  226   1      #if IMU660RA_USE_SOFT_IIC
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 5   

                   soft_iic_init(&imu660ra_iic_struct, IMU660RA_DEV_ADDR, IMU660RA_SOFT_IIC_DELAY, IMU660RA_SCL_PIN, IMU
             -660RA_SDA_PIN); // ÅäÖÃ IMU660RA µÄÈí¼þ IIC ¶Ë¿Ú
               #else
  229   1          spi_init(IMU660RA_SPI, SPI_MODE0, IMU660RA_SPI_SPEED, IMU660RA_SPC_PIN, IMU660RA_SDI_PIN, IMU660RA_SD
             -O_PIN, SPI_CS_NULL); // ÅäÖÃ IMU660RA µÄÓ²¼þ SPI ¶Ë¿Ú
  230   1          gpio_init(IMU660RA_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);                                           
             -                     // ÅäÖÃ IMU660RA µÄ CS ¶Ë¿Ú
  231   1          //  imu660ra_read_register(IMU660RA_CHIP_ID);                                   // ¶ÁÈ¡Éè±¸ ID ½«Éè±¸
             -ÉèÖÃÎª SPI Ä£Ê½
  232   1      #endif
  233   1      
  234   1          do
  235   1          {
  236   2              if (imu660ra_self_check()) // IMU660RA ×Ô¼ì
  237   2              {
  238   3                  // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâ??
  239   3                  // ÄÇÃ´¾ÍÊÇ IMU660RA ×Ô¼ì³ö´í²¢³¬Ê±ÍË³öÁË
  240   3                  // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇ»µ??
  241   3                  printf("imu660ra self check error.\r\n");
  242   3                  return_state = 1;
  243   3                  break;
  244   3              }
  245   2      
  246   2              imu660ra_write_register(IMU660RA_PWR_CONF, 0x00); // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
  247   2              system_delay_ms(1);
  248   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x00);                                               
             - // ¿ªÊ¼¶ÔÄ£¿é½øÐÐ³õÊ¼»¯ÅäÖÃ
  249   2              imu660ra_write_registers(IMU660RA_INIT_DATA, imu660ra_config_file, sizeof(imu660ra_config_file));
             - // Êä³öÅäÖÃÎÄ¼þ
  250   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x01);                                               
             - // ³õÊ¼»¯ÅäÖÃ½áÊø
  251   2              system_delay_ms(20);
  252   2      
  253   2              if (1 != imu660ra_read_register(IMU660RA_INT_STA)) // ¼ì²éÊÇ·ñÅäÖÃÍê³É
  254   2              {
  255   3                  // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâÀï
  256   3                  // ÄÇÃ´¾ÍÊÇ IMU660RA ÅäÖÃ³õÊ¼»¯ÎÄ¼þ³ö´íÁË
  257   3                  // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇÄ£¿éËð»µ
  258   3                  printf("imu660ra init error.\r\n");
  259   3                  return_state = 1;
  260   3                  break;
  261   3              }
  262   2      
  263   2              imu660ra_write_register(IMU660RA_PWR_CTRL, 0x0E); // ¿ªÆôÐÔÄÜÄ£Ê½  Ê¹ÄÜÍÓÂÝÒÇ¡¢¼ÓËÙ¶È¡¢ÎÂ¶È´«¸ÐÆ÷
  264   2              imu660ra_write_register(IMU660RA_ACC_CONF, 0xA7); // ¼ÓËÙ¶È²É¼¯ÅäÖÃ ÐÔÄÜÄ£Ê½ Õý³£²É¼¯ 50Hz  ²ÉÑùÆ
             -µÂÊ
  265   2              imu660ra_write_register(IMU660RA_GYR_CONF, 0xA9); // ÍÓÂÝÒÇ²É¼¯ÅäÖÃ ÐÔÄÜÄ£Ê½ Õý³£²É¼¯ 200Hz ²ÉÑùÆ
             -µÂÊ
  266   2      
  267   2              // IMU660RA_ACC_RANGE ¼Ä´æÆ÷
  268   2              // ÉèÖÃÎª 0x00 ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À2g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 16384 ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î» g
             -(m/s^2)
  269   2              // ÉèÖÃÎª 0x01 ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À4g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 8192  ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î» g
             -(m/s^2)
  270   2              // ÉèÖÃÎª 0x02 ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À8g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 4096  ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î» g
             -(m/s^2)
  271   2              // ÉèÖÃÎª 0x03 ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À16g  »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 2048  ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î» g
             -(m/s^2)
  272   2              switch (IMU660RA_ACC_SAMPLE_DEFAULT)
  273   2              {
  274   3              default:
  275   3              {
  276   4                  printf("IMU660RA_ACC_SAMPLE_DEFAULT set error.\r\n");
  277   4                  return_state = 1;
  278   4              }
  279   3              break;
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 6   

  280   3      
  281   3              case IMU660RA_ACC_SAMPLE_SGN_2G:
  282   3              {
  283   4                  imu660ra_write_register(IMU660RA_ACC_RANGE, 0x00);
  284   4                  imu660ra_transition_factor[0] = 16384;
  285   4              }
  286   3              break;
  287   3      
  288   3              case IMU660RA_ACC_SAMPLE_SGN_4G:
  289   3              {
  290   4                  imu660ra_write_register(IMU660RA_ACC_RANGE, 0x01);
  291   4                  imu660ra_transition_factor[0] = 8192;
  292   4              }
  293   3              break;
  294   3      
  295   3              case IMU660RA_ACC_SAMPLE_SGN_8G:
  296   3              {
  297   4                  imu660ra_write_register(IMU660RA_ACC_RANGE, 0x02);
  298   4                  imu660ra_transition_factor[0] = 4096;
  299   4              }
  300   3              break;
  301   3      
  302   3              case IMU660RA_ACC_SAMPLE_SGN_16G:
  303   3              {
  304   4                  imu660ra_write_register(IMU660RA_ACC_RANGE, 0x03);
  305   4                  imu660ra_transition_factor[0] = 2048;
  306   4              }
  307   3              break;
  308   3              }
  309   2      
  310   2              if (1 == return_state)
  311   2              {
  312   3                  break;
  313   3              }
  314   2      
  315   2              // IMU660RA_GYR_RANGE ¼Ä´æÆ÷
  316   2              // ÉèÖÃÎª 0x04 ÍÓÂÝÒÇÁ¿³Ì ¡À125 dps   »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 262.4  ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î»
             - ¡ã/s
  317   2              // ÉèÖÃÎª 0x03 ÍÓÂÝÒÇÁ¿³Ì ¡À250 dps   »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 131.2  ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î»
             - ¡ã/s
  318   2              // ÉèÖÃÎª 0x02 ÍÓÂÝÒÇÁ¿³Ì ¡À500 dps   »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 65.6   ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î»
             - ¡ã/s
  319   2              // ÉèÖÃÎª 0x01 ÍÓÂÝÒÇÁ¿³Ì ¡À1000 dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 32.8   ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î»
             - ¡ã/s
  320   2              // ÉèÖÃÎª 0x00 ÍÓÂÝÒÇÁ¿³Ì ¡À2000 dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 16.4   ¿É×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý µ¥Î»
             - ¡ã/s
  321   2              switch (IMU660RA_GYRO_SAMPLE_DEFAULT)
  322   2              {
  323   3              default:
  324   3              {
  325   4                  printf("IMU660RA_GYRO_SAMPLE_DEFAULT set error.\r\n");
  326   4                  return_state = 1;
  327   4              }
  328   3              break;
  329   3      
  330   3              case IMU660RA_GYRO_SAMPLE_SGN_125DPS:
  331   3              {
  332   4                  imu660ra_write_register(IMU660RA_GYR_RANGE, 0x04);
  333   4                  imu660ra_transition_factor[1] = 262.4;
  334   4              }
  335   3              break;
  336   3      
  337   3              case IMU660RA_GYRO_SAMPLE_SGN_250DPS:
  338   3              {
  339   4                  imu660ra_write_register(IMU660RA_GYR_RANGE, 0x03);
  340   4                  imu660ra_transition_factor[1] = 131.2;
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 26/11/25  15:19:33  PAGE 7   

  341   4              }
  342   3              break;
  343   3      
  344   3              case IMU660RA_GYRO_SAMPLE_SGN_500DPS:
  345   3              {
  346   4                  imu660ra_write_register(IMU660RA_GYR_RANGE, 0x02);
  347   4                  imu660ra_transition_factor[1] = 65.6;
  348   4              }
  349   3              break;
  350   3      
  351   3              case IMU660RA_GYRO_SAMPLE_SGN_1000DPS:
  352   3              {
  353   4                  imu660ra_write_register(IMU660RA_GYR_RANGE, 0x01);
  354   4                  imu660ra_transition_factor[1] = 32.8;
  355   4              }
  356   3              break;
  357   3      
  358   3              case IMU660RA_GYRO_SAMPLE_SGN_2000DPS:
  359   3              {
  360   4                  imu660ra_write_register(IMU660RA_GYR_RANGE, 0x00);
  361   4                  imu660ra_transition_factor[1] = 16.4;
  362   4              }
  363   3              break;
  364   3              }
  365   2      
  366   2              if (1 == return_state)
  367   2              {
  368   3                  break;
  369   3              }
  370   2          } while (0);
  371   1      
  372   1          return return_state;
  373   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1246     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        70     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       222     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
