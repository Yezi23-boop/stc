C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\menu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\menu.lst) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          /*********************************************
    3           * 菜单与菜单系统说明
    4           *********************************************/
    5          // 按键值定义
    6          #define KEYSTROKE_ONE 1   // 上
    7          #define KEYSTROKE_TWO 2   // 下
    8          #define KEYSTROKE_THREE 3 // 确认
    9          #define KEYSTROKE_FOUR 4  // 返回
   10          
   11          // 屏幕显示相关常量
   12          #define ROWS_MAX 7 * 18      // 屏幕上可移动光标的最大行
   13          #define ROWS_MIN 1 * 18      // 屏幕上可移动光标的最小行
   14          #define CENTER_COLUMN 12 * 8 // 居中列位置
   15          #define EEPROM_MODE 1        // EEPROM 读写模式设为 1
   16          
   17          /**
   18           * 全局状态变量
   19           */
   20          int display_codename = 0;       // 当前显示页面编码
   21          int cursor_row = 2 * 18;        // 当前光标所在行
   22          int previous_cursor_row = -1;   // 上一次光标所在行
   23          int menu_next_flag = 0;         // 菜单导航标志位（进入/返回）
   24          float change_unit = 0;          // 参数修改的步进单位值
   25          int change_unit_multiplier = 1; // 修改单位倍数
   26          int keystroke_three_count = 0;  // 统计 KEYSTROKE_THREE 的触发次数（防抖/长按）
   27          int Have_Sub_Menu(int menu_id);
   28          void Keystroke_Menu_HOME(void);
   29          void Menu_Start_Process(void);
   30          void Menu_Speed_Process(void);
   31          void Menu_Angle_Process(void);
   32          void Menu_Sensor_Process(void);
   33          void Menu_Circle_Process(void);
   34          // 菜单标题“负压”的点阵数据
   35          const uint8 chinese_data[] = {
   36              // "负"
   37              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x20,
   38              0x10, 0x3B, 0xFF, 0xF0, 0x0C, 0x33, 0x0C, 0x30, 0x06, 0x63, 0x0C, 0x30, 0x03, 0xC3, 0x0C, 0x30,
   39              0x01, 0x83, 0x0C, 0x30, 0x01, 0x83, 0xFF, 0xF0, 0x02, 0x83, 0x0C, 0x30, 0x04, 0xC3, 0x0C, 0x30,
   40              0x18, 0xC3, 0x0C, 0x30, 0x20, 0x43, 0x0C, 0x30, 0x00, 0xC3, 0xFF, 0xF0, 0x00, 0xE3, 0x00, 0x30,
   41              0x01, 0xE2, 0x00, 0x00, 0x01, 0x60, 0x00, 0x18, 0x03, 0x7F, 0xFF, 0xFC, 0x06, 0x61, 0x90, 0x00,
   42              0x04, 0x61, 0x88, 0x10, 0x08, 0x61, 0x88, 0x38, 0x10, 0x61, 0x8C, 0x70, 0x20, 0x61, 0x85, 0x80,
   43              0x40, 0x61, 0x86, 0x00, 0x00, 0x61, 0x83, 0x00, 0x00, 0x61, 0x89, 0xC0, 0x00, 0xC1, 0xB0, 0xE0,
   44              0x0F, 0xC1, 0xC0, 0x7E, 0x03, 0x83, 0x80, 0x18, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   45              // "压"
   46              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00,
   47              0x00, 0x03, 0x0C, 0x30, 0x00, 0x31, 0x8C, 0x30, 0x3F, 0xF8, 0xCC, 0x60, 0x01, 0x00, 0xCC, 0x80,
   48              0x01, 0x00, 0xCD, 0x00, 0x01, 0x02, 0x0D, 0x00, 0x01, 0x03, 0xFF, 0xF8, 0x01, 0x03, 0x00, 0x30,
   49              0x01, 0x03, 0x00, 0x30, 0x01, 0x13, 0x08, 0x30, 0x3F, 0xFB, 0x0E, 0x30, 0x01, 0x03, 0x0C, 0x30,
   50              0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30,
   51              0x01, 0x03, 0x08, 0x30, 0x01, 0x03, 0x08, 0x30, 0x01, 0x03, 0x18, 0x30, 0x01, 0x1F, 0x18, 0x30,
   52              0x01, 0xE2, 0x18, 0x00, 0x0F, 0x00, 0x36, 0x00, 0x3C, 0x00, 0x31, 0xC0, 0x30, 0x00, 0x60, 0xF0,
   53              0x00, 0x00, 0xC0, 0x38, 0x00, 0x03, 0x00, 0x1C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00,
   54              // "AI"
   55              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
   56              0x00, 0x0E, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x60, 0x0F, 0xFF, 0xFF, 0xF0,
   57              0x00, 0x18, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0xC0, 0x00, 0x00, 0x61, 0x80, 0x00,
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 2   

   58              0x00, 0xC1, 0x80, 0x00, 0x00, 0xC1, 0x80, 0x00, 0x01, 0x81, 0x80, 0x00, 0x03, 0x81, 0x80, 0xC0,
   59              0x07, 0xFF, 0xFF, 0xE0, 0x03, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00,
   60              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x18, 0x3F, 0xFF, 0xFF, 0xFC, 0x00, 0x01, 0x80, 0x00,
   61              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00,
   62              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};
   63          
   64          // 可进入的菜单页编码列表（用于防止光标进入不存在的菜单）
   65          int menu_have_sub[] = {
   66              0, // 主菜单
   67              1,
   68              11,
   69              12,
   70              13,
   71              14,
   72              15,
   73              16,
   74              17, // 速度参数菜单
   75              2,
   76              21,
   77              22,
   78              23,
   79              24,
   80              25,
   81              26, // PID_Direction 速度参数菜单
   82              3,
   83              31,
   84              32,
   85              33,
   86              34,
   87              35,
   88              36, // PID_Direction 角度参数菜单
   89              4,  // 传感器显示菜单
   90              5,
   91              51,
   92              52,
   93              53,
   94              54,
   95              55,
   96              56, // 圆环控制参数菜单
   97          };
   98          
   99          /**
  100           * @brief 光标移动与菜单进入/退出
  101           * @details 处理上下移动以及进入/返回操作
  102           */
  103          void Cursor(void)
  104          {
  105   1          menu_next_flag = 0;
  106   1          switch (keystroke_label)
  107   1          {
  108   2          case KEYSTROKE_ONE:
  109   2              cursor_row = (cursor_row > ROWS_MIN) ? cursor_row - 1 * 18 : ROWS_MAX; // 光标上移
  110   2              break;
  111   2          case KEYSTROKE_TWO:
  112   2              cursor_row = (cursor_row < ROWS_MAX) ? cursor_row + 1 * 18 : ROWS_MIN; // 光标下移
  113   2              break;
  114   2          case KEYSTROKE_THREE:
  115   2              menu_next_flag = 1; // 进入子菜单
  116   2              break;
  117   2          case KEYSTROKE_FOUR:
  118   2              menu_next_flag = -1; // 返回上级菜单
  119   2              break;
  120   2          }
  121   1      
  122   1          ips114_show_string(0, cursor_row, ">"); // 在当前位置显示箭头
  123   1      
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 3   

  124   1          // 清除之前箭头位置的显示，避免残影
  125   1          if (previous_cursor_row != cursor_row)
  126   1          {
  127   2              ips114_show_string(0, previous_cursor_row, " ");
  128   2              previous_cursor_row = cursor_row;
  129   2          }
  130   1      }
  131          
  132          /**
  133           * @brief 菜单事件跳转处理
  134           * @details 处理菜单层级的切换逻辑
  135           */
  136          void Menu_Next_Back()
  137          {
  138   1          int menu_id = 0;
  139   1          switch (menu_next_flag)
  140   1          {
  141   2          case 0:
  142   2              break;
  143   2          case -1: // 返回上一级
  144   2              display_codename = display_codename / 10;
  145   2              cursor_row = ROWS_MIN;
  146   2              ips114_clear(RGB565_WHITE);
  147   2              break;
  148   2          case 1: // 进入下一级
  149   2              menu_id = display_codename * 10 + (cursor_row / 18);
  150   2              if (Have_Sub_Menu(menu_id))
  151   2              {
  152   3                  display_codename = menu_id;
  153   3                  ips114_clear(RGB565_WHITE);
  154   3              }
  155   2              break;
  156   2          }
  157   1          menu_next_flag = 0;
  158   1      }
  159          
  160          /**
  161           * @brief 判断当前页是否存在子菜单
  162           * @param menu_id 菜单 ID
  163           * @return 1=存在子菜单，0=不存在子菜单
  164           */
  165          int Have_Sub_Menu(int menu_id)
  166          {
  167   1          int i = 0;
  168   1          for (i = 0; i < sizeof(menu_have_sub) / sizeof(menu_have_sub[0]); i++)
  169   1          {
  170   2              if (menu_have_sub[i] == menu_id)
  171   2                  return 1;
  172   2          }
  173   1          return 0;
  174   1      }
  175          
  176          /**
  177           * @brief 处理按键，扫描当前页并修改参数
  178           * @param keystroke_label 按键标识
  179           */
  180          void HandleKeystroke(int keystroke_label)
  181          {
  182   1          switch (keystroke_label)
  183   1          {
  184   2          case KEYSTROKE_FOUR:
  185   2              display_codename /= 10; // 返回上一页
  186   2              ips114_clear(RGB565_WHITE);
  187   2              break;
  188   2          case KEYSTROKE_THREE:
  189   2              keystroke_three_count++;
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 4   

  190   2              change_unit_multiplier = (keystroke_three_count % 3 == 0) ? 1 : (keystroke_three_count % 3 == 1) 
             -? 10
  191   2                                                                                                               
             -: 100;
  192   2              if (keystroke_three_count >= 3)
  193   2                  keystroke_three_count = 0;
  194   2              break;
  195   2          }
  196   1      }
  197          
  198          /**
  199           * @brief 整数参数修改
  200           * @param parameter 需修改的参数指针
  201           * @param change_unit_MIN 最小修改单位
  202           */
  203          void Keystroke_int(int *parameter, int change_unit_MIN)
  204          {
  205   1          int change_unit = change_unit_MIN * change_unit_multiplier;
  206   1          ips114_show_int32(15 * 8, 0, change_unit, 3);
  207   1      
  208   1          Keystroke_Scan();
  209   1          HandleKeystroke(keystroke_label);
  210   1      
  211   1          switch (keystroke_label)
  212   1          {
  213   2          case KEYSTROKE_ONE:
  214   2              *parameter += change_unit;
  215   2              break;
  216   2          case KEYSTROKE_TWO:
  217   2              *parameter -= change_unit;
  218   2              break;
  219   2          }
  220   1      }
  221          
  222          /**
  223           * @brief 浮点参数修改
  224           * @param parameter 需修改的参数指针
  225           * @param change_unit_MIN 最小修改单位
  226           */
  227          void Keystroke_float(float *parameter, float change_unit_MIN)
  228          {
  229   1          float change_unit = change_unit_MIN * change_unit_multiplier;
  230   1          ips114_show_float(14 * 8, 0, change_unit, 3, 3);
  231   1          Keystroke_Scan();
  232   1          HandleKeystroke(keystroke_label);
  233   1      
  234   1          switch (keystroke_label)
  235   1          {
  236   2          case KEYSTROKE_ONE:
  237   2              *parameter += change_unit;
  238   2              break;
  239   2          case KEYSTROKE_TWO:
  240   2              *parameter -= change_unit;
  241   2              break;
  242   2          }
  243   1      }
  244          
  245          /**
  246           * @brief 特殊取值修改（-1 与 1）
  247           * @param parameter 需修改的参数指针
  248           */
  249          void Keystroke_Special_Value(int *parameter)
  250          {
  251   1          Keystroke_Scan();
  252   1          HandleKeystroke(keystroke_label);
  253   1      
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 5   

  254   1          switch (keystroke_label)
  255   1          {
  256   2          case KEYSTROKE_ONE:
  257   2              *parameter = 1;
  258   2              break;
  259   2          case KEYSTROKE_TWO:
  260   2              *parameter = -1;
  261   2              break;
  262   2          }
  263   1      }
  264          
  265          /**
  266           * @brief 菜单目录控制
  267           * @details 根据 display_codename 显示对应菜单页面
  268           * @note 删除页面时请同步修改 menu_have_sub[] 列表
  269           */
  270          void Keystroke_Menu(void)
  271          {
  272   1          switch (display_codename)
  273   1          {
  274   2          case 0: // 主菜单
  275   2              Keystroke_Menu_HOME();
  276   2              break;
  277   2      
  278   2          case 1: // 速度参数菜单
  279   2          case 11:
  280   2          case 12:
  281   2          case 13:
  282   2          case 14:
  283   2          case 15:
  284   2          case 16:
  285   2          case 17:
  286   2              Menu_Start_Process();
  287   2              break;
  288   2      
  289   2          case 2: // PID_Direction 速度参数菜单
  290   2          case 21:
  291   2          case 22:
  292   2          case 23:
  293   2          case 24:
  294   2          case 25:
  295   2          case 26:
  296   2              Menu_Speed_Process();
  297   2              break;
  298   2      
  299   2          case 3: // PID_Direction 角度参数菜单
  300   2          case 31:
  301   2          case 32:
  302   2          case 33:
  303   2          case 34:
  304   2          case 35:
  305   2          case 36:
  306   2              Menu_Angle_Process();
  307   2              break;
  308   2      
  309   2          case 4: // 传感器显示菜单
  310   2              Menu_Sensor_Process();
  311   2              break;
  312   2      
  313   2          case 5: // 圆环控制参数菜单
  314   2          case 51:
  315   2          case 52:
  316   2          case 53:
  317   2          case 54:
  318   2          case 55:
  319   2          case 56:
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 6   

  320   2              Menu_Circle_Process();
  321   2              break;
  322   2      
  323   2          default:
  324   2              break;
  325   2          }
  326   1      }
  327          
  328          /*********************************************
  329           * 主菜单显示与处理
  330           *********************************************/
  331          void Keystroke_Menu_HOME(void)
  332          {
  333   1          while (menu_next_flag == 0)
  334   1          {
  335   2              // 显示菜单标题
  336   2              ips114_show_string(CENTER_COLUMN, 0, "MENU");
  337   2      
  338   2              // 显示菜单项
  339   2              ips114_show_string(8 * 2, 1 * 18, "STRAT");  // 启动设置
  340   2              ips114_show_string(8 * 2, 2 * 18, "PID_1");  // PID_Direction 速度参数
  341   2              ips114_show_string(8 * 2, 3 * 18, "PID_2");  // PID_Direction 角度参数
  342   2              ips114_show_string(8 * 2, 4 * 18, "PRINTF"); // 调试数据显示
  343   2              ips114_show_string(8 * 2, 5 * 18, "RING");   // 圆环控制参数
  344   2      
  345   2              // 显示实时数据标签
  346   2              ips114_show_string(7 * 15, 1 * 18, "Err");
  347   2              ips114_show_string(7 * 15, 2 * 18, "motor");
  348   2              ips114_show_string(7 * 15, 3 * 18, "phase");
  349   2              ips114_show_string(7 * 15, 4 * 18, "dianya");
  350   2              ips114_show_string(7 * 15, 5 * 18, "fuya_date");
  351   2              //        // 显示实时数值（整数显示以减少浮点格式化开销）
  352   2              ips114_show_int32(8 * 23, 1 * 18, Err, 3);
  353   2              // 显示位置式 PID_Direction 输出作为 motor
  354   2              ips114_show_float(8 * 23, 2 * 18, PID.steer.output, 3, 1);
  355   2              ips114_show_float(8 * 23, 3 * 18, phase, 3, 1);
  356   2              // 电压使用 mV 整数显示
  357   2              ips114_show_int32(8 * 23, 4 * 18, dianya, 5);
  358   2              ips114_show_int32(8 * 23, 5 * 18, fuya_date, 4);
  359   2      
  360   2              ips114_show_float(7 * 15, 6 * 18, speed_run - PID.steer.output, 4, 2);
  361   2              ips114_show_float(8 * 23, 6 * 18, speed_run + PID.steer.output, 4, 2);
  362   2              Keystroke_Scan();
  363   2              Cursor();
  364   2          }
  365   1      
  366   1          // 菜单跳转处理
  367   1          if (menu_next_flag == 1)
  368   1          {
  369   2              int menu_id = display_codename * 10 + (cursor_row / 18);
  370   2              if (Have_Sub_Menu(menu_id))
  371   2              {
  372   3                  display_codename = menu_id;
  373   3                  cursor_row = ROWS_MIN;
  374   3                  ips114_clear(RGB565_WHITE);
  375   3              }
  376   2          }
  377   1          // EEPROM 写入处理
  378   1          else if (menu_next_flag == -1 && EEPROM_MODE == 1)
  379   1          {
  380   2              eeprom_flash();
  381   2              // 刷写完成提示
  382   2              ips114_clear(RGB565_WHITE);
  383   2              ips114_show_chinese(11 * 6, 8 * 6, 32, chinese_data, 3, RGB565_BLACK);
  384   2              system_delay_ms(200);
  385   2              ips114_clear(RGB565_WHITE);
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 7   

  386   2          }
  387   1      
  388   1          menu_next_flag = 0;
  389   1      }
  390          
  391          /*********************************************
  392           * 速度参数菜单（子菜单 1）
  393           *********************************************/
  394          void Menu_Start_Show(uint8 control_line)
  395          {
  396   1          ips114_show_string(4 * 8, 0 * 18, "<<STRAT");
  397   1      
  398   1          ips114_show_string(1 * 8, 1 * 18, "Start_Flag");   // 启动标志
  399   1          ips114_show_string(1 * 8, 2 * 18, "circle_flags"); // 出环方向标志
  400   1      
  401   1          ips114_show_int32(14 * 8, 1 * 18, start_flag, 3);
  402   1          ips114_show_int32(14 * 8, 2 * 18, circle_flags, 3);
  403   1      
  404   1          // 显示当前编辑标识
  405   1          if (control_line == 1)
  406   1          {
  407   2              ips114_show_string(0, control_line, " ");
  408   2          }
  409   1          else
  410   1          {
  411   2              ips114_show_string(0, control_line, "&");
  412   2          }
  413   1      }
  414          
  415          void Menu_Start_Process(void)
  416          {
  417   1          switch (display_codename)
  418   1          {
  419   2          case 1: // 速度参数主菜单
  420   2              while (menu_next_flag == 0)
  421   2              {
  422   3                  Menu_Start_Show(1);
  423   3                  Keystroke_Scan();
  424   3                  Cursor();
  425   3              }
  426   2              Menu_Next_Back();
  427   2              break;
  428   2      
  429   2          case 11: // 启动标志修改
  430   2              Menu_Start_Show(1 * 18);
  431   2              Keystroke_Special_Value(&start_flag);
  432   2              break;
  433   2          case 12: // 出环方向修改
  434   2              Menu_Start_Show(2 * 18);
  435   2              Keystroke_Special_Value(&circle_flags);
  436   2              break;
  437   2          }
  438   1      }
  439          
  440          /*********************************************
  441           * PID_Direction 速度参数菜单（子菜单 2）
  442           *********************************************/
  443          void Menu_Speed_Show(uint8 control_line)
  444          {
  445   1          ips114_show_string(1 * 8, 0 * 18, "<<PID_SPEED");
  446   1      
  447   1          ips114_show_string(1 * 8, 1 * 18, "kp_Err");     // 位置误差比例系数
  448   1          ips114_show_string(1 * 8, 2 * 18, "kd_Err");     // 位置误差微分系数
  449   1          ips114_show_string(1 * 8, 3 * 18, "speed_run");  // 运行速度
  450   1          ips114_show_string(1 * 8, 4 * 18, "kd_gyro");    // 陀螺微分权重
  451   1          ips114_show_string(1 * 8, 5 * 18, "fuya_xili");  // 负压吸力
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 8   

  452   1          ips114_show_string(1 * 8, 6 * 18, "pwm_filter"); // PWM 滤波
  453   1      
  454   1          ips114_show_float(14 * 8, 1 * 18, kp_Err, 3, 3);
  455   1          ips114_show_float(14 * 8, 2 * 18, kd_Err, 3, 3);
  456   1          ips114_show_float(14 * 8, 3 * 18, speed_run, 3, 3);
  457   1          ips114_show_float(14 * 8, 4 * 18, kd_gyro, 3, 3);
  458   1          ips114_show_float(14 * 8, 5 * 18, fuya_xili, 4, 3);
  459   1          ips114_show_float(14 * 8, 6 * 18, pwm_filter, 3, 3);
  460   1      
  461   1          // 显示当前编辑标识
  462   1          if (control_line == 1)
  463   1          {
  464   2              ips114_show_string(0, control_line, " ");
  465   2          }
  466   1          else
  467   1          {
  468   2              ips114_show_string(0, control_line, "&");
  469   2          }
  470   1      }
  471          
  472          void Menu_Speed_Process(void)
  473          {
  474   1          switch (display_codename)
  475   1          {
  476   2          case 2: // PID_Direction 速度参数主菜单
  477   2              while (menu_next_flag == 0)
  478   2              {
  479   3                  Menu_Speed_Show(0);
  480   3                  Keystroke_Scan();
  481   3                  Cursor();
  482   3              }
  483   2              Menu_Next_Back();
  484   2              break;
  485   2      
  486   2          case 21: // 位置误差比例系数
  487   2              Menu_Speed_Show(1 * 18);
  488   2              Keystroke_float(&kp_Err, 0.01);
  489   2              break;
  490   2          case 22: // 位置误差微分系数
  491   2              Menu_Speed_Show(2 * 18);
  492   2              Keystroke_float(&kd_Err, 0.1);
  493   2              break;
  494   2          case 23: // 运行速度
  495   2              Menu_Speed_Show(3 * 18);
  496   2              Keystroke_float(&speed_run, 1);
  497   2              break;
  498   2          case 24: // 陀螺微分权重
  499   2              Menu_Speed_Show(4 * 18);
  500   2              Keystroke_float(&kd_gyro, 0.01);
  501   2              break;
  502   2          case 25: // 负压吸力
  503   2              Menu_Speed_Show(5 * 18);
  504   2              Keystroke_float(&fuya_xili, 100);
  505   2              break;
  506   2          case 26: // PWM 滤波
  507   2              Menu_Speed_Show(6 * 18);
  508   2              Keystroke_float(&pwm_filter, 0.1);
  509   2              break;
  510   2          }
  511   1      }
  512          
  513          /*********************************************
  514           * PID_Direction 角度参数菜单（子菜单 3）
  515           *********************************************/
  516          void Menu_Angle_Show(uint8 control_line)
  517          {
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 9   

  518   1          ips114_show_string(1 * 8, 0 * 18, "<<PID_ANGLE");
  519   1      
  520   1          ips114_show_string(1 * 8, 1 * 18, "kp_Angle");       // 角度比例系数
  521   1          ips114_show_string(1 * 8, 2 * 18, "kd_Angle");       // 角度微分系数
  522   1          ips114_show_string(1 * 8, 3 * 18, "limiting_Angle"); // 角度限幅
  523   1          ips114_show_string(1 * 8, 4 * 18, "A_1");            // 校正 A_1
  524   1          ips114_show_string(1 * 8, 5 * 18, "B_1");            // 校正 B_1
  525   1          ips114_show_string(1 * 8, 6 * 18, "C_l");            // 额外微调
  526   1      
  527   1          ips114_show_float(15 * 8, 1 * 18, kp_Angle, 3, 2);
  528   1          ips114_show_float(15 * 8, 2 * 18, kd_Angle, 3, 2);
  529   1          ips114_show_float(15 * 8, 3 * 18, limiting_Angle, 3, 2);
  530   1          ips114_show_float(14 * 8, 4 * 18, A_1, 3, 2);
  531   1          ips114_show_float(14 * 8, 5 * 18, B_1, 3, 2);
  532   1          ips114_show_float(14 * 8, 6 * 18, C_l, 3, 3);
  533   1      
  534   1          // 显示当前编辑标识
  535   1          if (control_line == 1)
  536   1          {
  537   2              ips114_show_string(0, control_line, " ");
  538   2          }
  539   1          else
  540   1          {
  541   2              ips114_show_string(0, control_line, "&");
  542   2          }
  543   1      }
  544          
  545          void Menu_Angle_Process(void)
  546          {
  547   1          switch (display_codename)
  548   1          {
  549   2          case 3: // PID_Direction 角度参数主菜单
  550   2              while (menu_next_flag == 0)
  551   2              {
  552   3                  Menu_Angle_Show(1);
  553   3                  Keystroke_Scan();
  554   3                  Cursor();
  555   3              }
  556   2              Menu_Next_Back();
  557   2              break;
  558   2      
  559   2          case 31: // 角度比例系数
  560   2              Menu_Angle_Show(1 * 18);
  561   2              Keystroke_float(&kp_Angle, 0.01);
  562   2              break;
  563   2          case 32: // 角度微分系数
  564   2              Menu_Angle_Show(2 * 18);
  565   2              Keystroke_float(&kd_Angle, 0.01);
  566   2              break;
  567   2          case 33: // 角度限幅
  568   2              Menu_Angle_Show(3 * 18);
  569   2              Keystroke_float(&limiting_Angle, 10);
  570   2              break;
  571   2          case 34: // 校正 A_1
  572   2              Menu_Angle_Show(4 * 18);
  573   2              Keystroke_float(&A_1, 0.01);
  574   2              break;
  575   2          case 35: // 校正 B_1
  576   2              Menu_Angle_Show(5 * 18);
  577   2              Keystroke_float(&B_1, 0.01);
  578   2              break;
  579   2          case 36: // 额外微调
  580   2              Menu_Angle_Show(6 * 18);
  581   2              Keystroke_float(&C_l, 0.01);
  582   2              break;
  583   2          }
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 10  

  584   1      }
  585          
  586          /*********************************************
  587           * 传感器显示菜单（子菜单 4）
  588           *********************************************/
  589          void Menu_Sensor_Show(void)
  590          {
  591   1          // 显示赛道的标签（依次为 ad1..ad4）
  592   1          ips114_show_string(1 * 14, 18 * 0, "ad1"); // 左前
  593   1          ips114_show_string(1 * 14, 18 * 1, "ad2"); // 左后
  594   1          ips114_show_string(1 * 14, 18 * 3, "ad3"); // 右前
  595   1          ips114_show_string(1 * 14, 18 * 5, "ad4"); // 右后
  596   1      
  597   1          // 显示当前值（0-100），使用整数显示
  598   1          ips114_show_int32(14 * 4, 18 * 0, ad1, 3);
  599   1          ips114_show_int32(14 * 4, 18 * 1, ad2, 3);
  600   1          ips114_show_int32(14 * 4, 18 * 3, ad3, 3);
  601   1          ips114_show_int32(14 * 4, 18 * 5, ad4, 3);
  602   1      
  603   1          // 显示标定最大值（整数显示供参考）
  604   1          ips114_show_int32(14 * 8, 18 * 0, MA[0], 5); // ad1 最大值
  605   1          ips114_show_int32(14 * 8, 18 * 1, MA[1], 5); // ad2 最大值
  606   1          ips114_show_int32(14 * 8, 18 * 2, MA[2], 5); // ad3 最大值
  607   1          ips114_show_int32(14 * 8, 18 * 3, MA[3], 5); // ad4 最大值
  608   1      }
  609          
  610          void Menu_Sensor_Process(void)
  611          {
  612   1          switch (display_codename)
  613   1          {
  614   2          case 4:
  615   2              while (menu_next_flag == 0)
  616   2              {
  617   3                  Menu_Sensor_Show();
  618   3                  Keystroke_Scan();
  619   3                  Cursor();
  620   3              }
  621   2              Menu_Next_Back();
  622   2              break;
  623   2          }
  624   1      }
  625          /*********************************************
  626           * 圆环控制参数菜单（子菜单 5）
  627           *********************************************/
  628          void Menu_Circle_Show(uint8 control_line)
  629          {
  630   1          ips114_show_string(1 * 8, 0 * 18, "<<RING_CTRL");
  631   1      
  632   1          ips114_show_string(1 * 8, 1 * 18, "ring_en"); // 圆环编码器开关值
  633   1          ips114_show_string(1 * 8, 2 * 18, "p_r_G");   // 入环前陀螺设定值
  634   1          ips114_show_string(1 * 8, 3 * 18, "i_r_G");   // 入环陀螺 Z 轴值
  635   1          ips114_show_string(1 * 8, 4 * 18, "p_o_G");   // 出环前陀螺设定值
  636   1          ips114_show_string(1 * 8, 5 * 18, "p_o__G");  // 出环前陀螺 Z 值
  637   1          ips114_show_string(1 * 8, 6 * 18, "p_o_en");  // 出环编码器开关值
  638   1      
  639   1          ips114_show_float(14 * 8, 1 * 18, ring_encoder, 3, 2);
  640   1          ips114_show_float(14 * 8, 2 * 18, pre_ring_Gyro_set, 3, 2);
  641   1          ips114_show_float(14 * 8, 3 * 18, in_ring_Gyroz, 3, 2);
  642   1          ips114_show_float(14 * 8, 4 * 18, pre_out_ring_Gyro_set, 3, 2);
  643   1          ips114_show_float(14 * 8, 5 * 18, pre_out_ring_Gyroz, 3, 2);
  644   1          ips114_show_float(14 * 8, 6 * 18, pre_out_ring_encoder, 3, 2);
  645   1      
  646   1          // 显示当前编辑标识
  647   1          if (control_line == 1)
  648   1          {
  649   2              ips114_show_string(0, control_line, " ");
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 11  

  650   2          }
  651   1          else
  652   1          {
  653   2              ips114_show_string(0, control_line, "&");
  654   2          }
  655   1      }
  656          
  657          void Menu_Circle_Process(void)
  658          {
  659   1          switch (display_codename)
  660   1          {
  661   2          case 5: // 圆环控制参数主菜单
  662   2              while (menu_next_flag == 0)
  663   2              {
  664   3                  Menu_Circle_Show(1);
  665   3                  Keystroke_Scan();
  666   3                  Cursor();
  667   3              }
  668   2              Menu_Next_Back();
  669   2              break;
  670   2      
  671   2          case 51: // 圆环编码器开关值
  672   2              Menu_Circle_Show(1 * 18);
  673   2              Keystroke_float(&ring_encoder, 1);
  674   2              break;
  675   2          case 52: // 入环前陀螺设定值
  676   2              Menu_Circle_Show(2 * 18);
  677   2              Keystroke_float(&pre_ring_Gyro_set, 10);
  678   2              break;
  679   2          case 53: // 入环陀螺 Z 轴值
  680   2              Menu_Circle_Show(3 * 18);
  681   2              Keystroke_float(&in_ring_Gyroz, 10);
  682   2              break;
  683   2          case 54: // 出环前陀螺设定值
  684   2              Menu_Circle_Show(4 * 18);
  685   2              Keystroke_float(&pre_out_ring_Gyro_set, 10);
  686   2              break;
  687   2          case 55: // 出环前陀螺 Z 值
  688   2              Menu_Circle_Show(5 * 18);
  689   2              Keystroke_float(&pre_out_ring_Gyroz, 10);
  690   2              break;
  691   2          case 56: // 出环编码器开关值
  692   2              Menu_Circle_Show(6 * 18);
  693   2              Keystroke_float(&pre_out_ring_encoder, 1);
  694   2              break;
  695   2          }
  696   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4508     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       116     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       798     ------
C251 COMPILER V5.60.0,  menu                                                               22/11/25  23:09:29  PAGE 12  

End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
