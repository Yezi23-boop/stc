C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\user\menu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\menu.lst) TABS(2) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          /*********************************************
    3           * 菜单与菜单系统说明
    4           *********************************************/
    5          // 按键值定义
    6          #define KEYSTROKE_ONE 1   // 上
    7          #define KEYSTROKE_TWO 2   // 下
    8          #define KEYSTROKE_THREE 3 // 确认
    9          #define KEYSTROKE_FOUR 4  // 返回
   10          
   11          // 屏幕显示相关常量
   12          #define ROWS_MAX 7 * 18      // 屏幕上可移动光标的最大行
   13          #define ROWS_MIN 1 * 18      // 屏幕上可移动光标的最小行
   14          #define CENTER_COLUMN 12 * 8 // 居中列位置
   15          #define EEPROM_MODE 1        // EEPROM 读写模式设为 1
   16          
   17          /**
   18           * 全局状态变量
   19           */
   20          int display_codename = 0;       // 当前显示页面编码
   21          int cursor_row = 2 * 18;        // 当前光标所在行
   22          int previous_cursor_row = -1;   // 上一次光标所在行
   23          int menu_next_flag = 0;         // 菜单导航标志位（进入/返回）
   24          float change_unit = 0;          // 参数修改的步进单位值
   25          int change_unit_multiplier = 1; // 修改单位倍数
   26          int keystroke_three_count = 0;  // 统计 KEYSTROKE_THREE 的触发次数（防抖/长按）
   27          int Have_Sub_Menu(int menu_id);
   28          void Keystroke_Menu_HOME(void);
   29          void Menu_Start_Process(void);
   30          void Menu_Speed_Process(void);
   31          void Menu_Angle_Process(void);
   32          void Menu_Sensor_Process(void);
   33          void Menu_Circle_Process(void);
   34          // 菜单标题“负压”的点阵数据
   35          const uint8 chinese_data[] = {
   36              // "负"
   37              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x20,
   38              0x10, 0x3B, 0xFF, 0xF0, 0x0C, 0x33, 0x0C, 0x30, 0x06, 0x63, 0x0C, 0x30, 0x03, 0xC3, 0x0C, 0x30,
   39              0x01, 0x83, 0x0C, 0x30, 0x01, 0x83, 0xFF, 0xF0, 0x02, 0x83, 0x0C, 0x30, 0x04, 0xC3, 0x0C, 0x30,
   40              0x18, 0xC3, 0x0C, 0x30, 0x20, 0x43, 0x0C, 0x30, 0x00, 0xC3, 0xFF, 0xF0, 0x00, 0xE3, 0x00, 0x30,
   41              0x01, 0xE2, 0x00, 0x00, 0x01, 0x60, 0x00, 0x18, 0x03, 0x7F, 0xFF, 0xFC, 0x06, 0x61, 0x90, 0x00,
   42              0x04, 0x61, 0x88, 0x10, 0x08, 0x61, 0x88, 0x38, 0x10, 0x61, 0x8C, 0x70, 0x20, 0x61, 0x85, 0x80,
   43              0x40, 0x61, 0x86, 0x00, 0x00, 0x61, 0x83, 0x00, 0x00, 0x61, 0x89, 0xC0, 0x00, 0xC1, 0xB0, 0xE0,
   44              0x0F, 0xC1, 0xC0, 0x7E, 0x03, 0x83, 0x80, 0x18, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   45              // "压"
   46              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00,
   47              0x00, 0x03, 0x0C, 0x30, 0x00, 0x31, 0x8C, 0x30, 0x3F, 0xF8, 0xCC, 0x60, 0x01, 0x00, 0xCC, 0x80,
   48              0x01, 0x00, 0xCD, 0x00, 0x01, 0x02, 0x0D, 0x00, 0x01, 0x03, 0xFF, 0xF8, 0x01, 0x03, 0x00, 0x30,
   49              0x01, 0x03, 0x00, 0x30, 0x01, 0x13, 0x08, 0x30, 0x3F, 0xFB, 0x0E, 0x30, 0x01, 0x03, 0x0C, 0x30,
   50              0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30, 0x01, 0x03, 0x0C, 0x30,
   51              0x01, 0x03, 0x08, 0x30, 0x01, 0x03, 0x08, 0x30, 0x01, 0x03, 0x18, 0x30, 0x01, 0x1F, 0x18, 0x30,
   52              0x01, 0xE2, 0x18, 0x00, 0x0F, 0x00, 0x36, 0x00, 0x3C, 0x00, 0x31, 0xC0, 0x30, 0x00, 0x60, 0xF0,
   53              0x00, 0x00, 0xC0, 0x38, 0x00, 0x03, 0x00, 0x1C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00,
   54              // "AI"
   55              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
   56              0x00, 0x0E, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x60, 0x0F, 0xFF, 0xFF, 0xF0,
   57              0x00, 0x18, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0xC0, 0x00, 0x00, 0x61, 0x80, 0x00,
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 2   

   58              0x00, 0xC1, 0x80, 0x00, 0x00, 0xC1, 0x80, 0x00, 0x01, 0x81, 0x80, 0x00, 0x03, 0x81, 0x80, 0xC0,
   59              0x07, 0xFF, 0xFF, 0xE0, 0x03, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00,
   60              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x18, 0x3F, 0xFF, 0xFF, 0xFC, 0x00, 0x01, 0x80, 0x00,
   61              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00,
   62              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};
   63          
   64          // 可进入的菜单页编码列表（用于防止光标进入不存在的菜单）
   65          int menu_have_sub[] = {
   66              0, // 主菜单
   67              1,
   68              11,
   69              12,
   70              13,
   71              14,
   72              15,
   73              16,
   74              17, // 速度参数菜单
   75              2,
   76              21,
   77              22,
   78              23,
   79              24,
   80              25,
   81              26, // PID_Direction 速度参数菜单
   82              3,
   83              31,
   84              32,
   85              33,
   86              34,
   87              35,
   88              36, // PID_Direction 角度参数菜单
   89              4,  // 传感器显示菜单
   90              5,
   91              51,
   92              52,
   93              53,
   94              54,
   95              55,
   96              56, // 圆环控制参数菜单
   97          };
   98          
   99          /**
  100           * @brief 光标移动与菜单进入/退出
  101           * @details 处理上下移动以及进入/返回操作
  102           */
  103          void Cursor(void)
  104          {
  105   1          menu_next_flag = 0;
  106   1          switch (keystroke_label)
  107   1          {
  108   2          case KEYSTROKE_ONE:
  109   2              cursor_row = (cursor_row > ROWS_MIN) ? cursor_row - 1 * 18 : ROWS_MAX; // 光标上移
  110   2              break;
  111   2          case KEYSTROKE_TWO:
  112   2              cursor_row = (cursor_row < ROWS_MAX) ? cursor_row + 1 * 18 : ROWS_MIN; // 光标下移
  113   2              break;
  114   2          case KEYSTROKE_THREE:
  115   2              menu_next_flag = 1; // 进入子菜单
  116   2              break;
  117   2          case KEYSTROKE_FOUR:
  118   2              menu_next_flag = -1; // 返回上级菜单
  119   2              break;
  120   2          }
  121   1      
  122   1          ips114_show_string(0, cursor_row, ">"); // 在当前位置显示箭头
  123   1      
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 3   

  124   1          // 清除之前箭头位置的显示，避免残影
  125   1          if (previous_cursor_row != cursor_row)
  126   1          {
  127   2              ips114_show_string(0, previous_cursor_row, " ");
  128   2              previous_cursor_row = cursor_row;
  129   2          }
  130   1      }
  131          
  132          /**
  133           * @brief 菜单事件跳转处理
  134           * @details 处理菜单层级的切换逻辑
  135           */
  136          void Menu_Next_Back()
  137          {
  138   1          int menu_id = 0;
  139   1          switch (menu_next_flag)
  140   1          {
  141   2          case 0:
  142   2              break;
  143   2          case -1: // 返回上一级
  144   2              display_codename = display_codename / 10;
  145   2              cursor_row = ROWS_MIN;
  146   2              ips114_clear(RGB565_WHITE);
  147   2              break;
  148   2          case 1: // 进入下一级
  149   2              menu_id = display_codename * 10 + (cursor_row / 18);
  150   2              if (Have_Sub_Menu(menu_id))
  151   2              {
  152   3                  display_codename = menu_id;
  153   3                  ips114_clear(RGB565_WHITE);
  154   3              }
  155   2              break;
  156   2          }
  157   1          menu_next_flag = 0;
  158   1      }
  159          
  160          /**
  161           * @brief 判断当前页是否存在子菜单
  162           * @param menu_id 菜单 ID
  163           * @return 1=存在子菜单，0=不存在子菜单
  164           */
  165          int Have_Sub_Menu(int menu_id)
  166          {
  167   1          int i = 0;
  168   1          for (i = 0; i < sizeof(menu_have_sub) / sizeof(menu_have_sub[0]); i++)
  169   1          {
  170   2              if (menu_have_sub[i] == menu_id)
  171   2                  return 1;
  172   2          }
  173   1          return 0;
  174   1      }
  175          
  176          /**
  177           * @brief 处理按键，扫描当前页并修改参数
  178           * @param keystroke_label 按键标识
  179           */
  180          void HandleKeystroke(int keystroke_label)
  181          {
  182   1          switch (keystroke_label)
  183   1          {
  184   2          case KEYSTROKE_FOUR:
  185   2              display_codename /= 10; // 返回上一页
  186   2              ips114_clear(RGB565_WHITE);
  187   2              break;
  188   2          case KEYSTROKE_THREE:
  189   2              keystroke_three_count++;
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 4   

  190   2              change_unit_multiplier = (keystroke_three_count % 3 == 0) ? 1 : (keystroke_three_count % 3 == 1) 
             -? 10
  191   2                                                                                                               
             -: 100;
  192   2              if (keystroke_three_count >= 3)
  193   2                  keystroke_three_count = 0;
  194   2              break;
  195   2          }
  196   1      }
  197          
  198          /**
  199           * @brief 整数参数修改
  200           * @param parameter 需修改的参数指针
  201           * @param change_unit_MIN 最小修改单位
  202           */
  203          void Keystroke_int(int *parameter, int change_unit_MIN)
  204          {
  205   1          int change_unit = change_unit_MIN * change_unit_multiplier;
  206   1          ips114_show_int32(15 * 8, 0, change_unit, 3);
  207   1      
  208   1          Keystroke_Scan();
  209   1          HandleKeystroke(keystroke_label);
  210   1      
  211   1          switch (keystroke_label)
  212   1          {
  213   2          case KEYSTROKE_ONE:
  214   2              *parameter += change_unit;
  215   2              break;
  216   2          case KEYSTROKE_TWO:
  217   2              *parameter -= change_unit;
  218   2              break;
  219   2          }
  220   1      }
  221          
  222          /**
  223           * @brief 浮点参数修改
  224           * @param parameter 需修改的参数指针
  225           * @param change_unit_MIN 最小修改单位
  226           */
  227          void Keystroke_float(float *parameter, float change_unit_MIN)
  228          {
  229   1          float change_unit = change_unit_MIN * change_unit_multiplier;
  230   1          ips114_show_float(14 * 8, 0, change_unit, 3, 3);
  231   1          Keystroke_Scan();
  232   1          HandleKeystroke(keystroke_label);
  233   1      
  234   1          switch (keystroke_label)
  235   1          {
  236   2          case KEYSTROKE_ONE:
  237   2              *parameter += change_unit;
  238   2              break;
  239   2          case KEYSTROKE_TWO:
  240   2              *parameter -= change_unit;
  241   2              break;
  242   2          }
  243   1      }
  244          
  245          /**
  246           * @brief 特殊取值修改（-1 与 1）
  247           * @param parameter 需修改的参数指针
  248           */
  249          void Keystroke_Special_Value(int *parameter)
  250          {
  251   1          Keystroke_Scan();
  252   1          HandleKeystroke(keystroke_label);
  253   1      
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 5   

  254   1          switch (keystroke_label)
  255   1          {
  256   2          case KEYSTROKE_ONE:
  257   2              *parameter = 1;
  258   2              break;
  259   2          case KEYSTROKE_TWO:
  260   2              *parameter = -1;
  261   2              break;
  262   2          }
  263   1      }
  264          
  265          /**
  266           * @brief 菜单目录控制
  267           * @details 根据 display_codename 显示对应菜单页面
  268           * @note 删除页面时请同步修改 menu_have_sub[] 列表
  269           */
  270          void Keystroke_Menu(void)
  271          {
  272   1          switch (display_codename)
  273   1          {
  274   2          case 0: // 主菜单
  275   2              Keystroke_Menu_HOME();
  276   2              break;
  277   2      
  278   2          case 1: // 速度参数菜单
  279   2          case 11:
  280   2          case 12:
  281   2          case 13:
  282   2          case 14:
  283   2          case 15:
  284   2          case 16:
  285   2          case 17:
  286   2              Menu_Start_Process();
  287   2              break;
  288   2      
  289   2          case 2: // PID_Direction 速度参数菜单
  290   2          case 21:
  291   2          case 22:
  292   2          case 23:
  293   2          case 24:
  294   2          case 25:
  295   2          case 26:
  296   2              Menu_Speed_Process();
  297   2              break;
  298   2      
  299   2          case 3: // PID_Direction 角度参数菜单
  300   2          case 31:
  301   2          case 32:
  302   2          case 33:
  303   2          case 34:
  304   2          case 35:
  305   2          case 36:
  306   2              Menu_Angle_Process();
  307   2              break;
  308   2      
  309   2          case 4: // 传感器显示菜单
  310   2              Menu_Sensor_Process();
  311   2              break;
  312   2      
  313   2          case 5: // 圆环控制参数菜单
  314   2          case 51:
  315   2          case 52:
  316   2          case 53:
  317   2          case 54:
  318   2          case 55:
  319   2          case 56:
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 6   

  320   2              Menu_Circle_Process();
  321   2              break;
  322   2      
  323   2          default:
  324   2              break;
  325   2          }
  326   1      }
  327          
  328          /*********************************************
  329           * 主菜单显示与处理
  330           *********************************************/
  331          void Keystroke_Menu_HOME(void)
  332          {
  333   1          while (menu_next_flag == 0)
  334   1          {
  335   2              // 显示菜单标题
  336   2              ips114_show_string(CENTER_COLUMN, 0, "MENU");
  337   2      
  338   2              // 显示菜单项
  339   2              ips114_show_string(8 * 2, 1 * 18, "STRAT");  // 启动设置
  340   2              ips114_show_string(8 * 2, 2 * 18, "PID_1");  // PID_Direction 速度参数
  341   2              ips114_show_string(8 * 2, 3 * 18, "PID_2");  // PID_Direction 角度参数
  342   2              ips114_show_string(8 * 2, 4 * 18, "PRINTF"); // 调试数据显示
  343   2              ips114_show_string(8 * 2, 5 * 18, "RING");   // 圆环控制参数
  344   2      
  345   2              // 显示实时数据标签
  346   2              ips114_show_string(7 * 15, 1 * 18, "Err");
  347   2              ips114_show_string(7 * 15, 2 * 18, "motor");
  348   2              ips114_show_string(7 * 15, 3 * 18, "phase");
  349   2              ips114_show_string(7 * 15, 4 * 18, "dianya");
  350   2              ips114_show_string(7 * 15, 5 * 18, "fuya_date");
  351   2              ips114_show_float(8 * 23, 1 * 18, Err, 3,2);
  352   2              // 显示位置式 PID_Direction 输出作为 motor
  353   2              ips114_show_float(8 * 23, 2 * 18, PID.steer.output, 3, 1);
  354   2              ips114_show_float(8 * 23, 3 * 18, phase, 3, 1);
  355   2              // 电压使用 mV 整数显示
  356   2              ips114_show_int32(8 * 23, 4 * 18, dianya, 5);
  357   2              ips114_show_int32(8 * 23, 5 * 18, fuya_date, 4);
  358   2      
  359   2              ips114_show_float(7 * 15, 6 * 18, speed_run - PID.steer.output, 4, 2);
  360   2              ips114_show_float(8 * 23, 6 * 18, speed_run + PID.steer.output, 4, 2);
  361   2              Keystroke_Scan();
  362   2              Cursor();
  363   2          }
  364   1      
  365   1          // 菜单跳转处理
  366   1          if (menu_next_flag == 1)
  367   1          {
  368   2              int menu_id = display_codename * 10 + (cursor_row / 18);
  369   2              if (Have_Sub_Menu(menu_id))
  370   2              {
  371   3                  display_codename = menu_id;
  372   3                  cursor_row = ROWS_MIN;
  373   3                  ips114_clear(RGB565_WHITE);
  374   3              }
  375   2          }
  376   1          // EEPROM 写入处理
  377   1          else if (menu_next_flag == -1 && EEPROM_MODE == 1)
  378   1          {
  379   2              eeprom_flash();
  380   2              // 刷写完成提示
  381   2              ips114_clear(RGB565_WHITE);
  382   2              ips114_show_chinese(11 * 6, 8 * 6, 32, chinese_data, 3, RGB565_BLACK);
  383   2              system_delay_ms(200);
  384   2              ips114_clear(RGB565_WHITE);
  385   2          }
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 7   

  386   1      
  387   1          menu_next_flag = 0;
  388   1      }
  389          
  390          /*********************************************
  391           * 速度参数菜单（子菜单 1）
  392           *********************************************/
  393          void Menu_Start_Show(uint8 control_line)
  394          {
  395   1          ips114_show_string(4 * 8, 0 * 18, "<<STRAT");
  396   1      
  397   1          ips114_show_string(1 * 8, 1 * 18, "Start_Flag");   // 启动标志
  398   1          ips114_show_string(1 * 8, 2 * 18, "circle_flags"); // 出环方向标志
  399   1      
  400   1          ips114_show_int32(14 * 8, 1 * 18, start_flag, 3);
  401   1          ips114_show_int32(14 * 8, 2 * 18, circle_flags, 3);
  402   1      
  403   1          // 显示当前编辑标识
  404   1          if (control_line == 1)
  405   1          {
  406   2              ips114_show_string(0, control_line, " ");
  407   2          }
  408   1          else
  409   1          {
  410   2              ips114_show_string(0, control_line, "&");
  411   2          }
  412   1      }
  413          
  414          void Menu_Start_Process(void)
  415          {
  416   1          switch (display_codename)
  417   1          {
  418   2          case 1: // 速度参数主菜单
  419   2              while (menu_next_flag == 0)
  420   2              {
  421   3                  Menu_Start_Show(1);
  422   3                  Keystroke_Scan();
  423   3                  Cursor();
  424   3              }
  425   2              Menu_Next_Back();
  426   2              break;
  427   2      
  428   2          case 11: // 启动标志修改
  429   2              Menu_Start_Show(1 * 18);
  430   2              Keystroke_Special_Value(&start_flag);
  431   2              break;
  432   2          case 12: // 出环方向修改
  433   2              Menu_Start_Show(2 * 18);
  434   2              Keystroke_Special_Value(&circle_flags);
  435   2              break;
  436   2          }
  437   1      }
  438          
  439          /*********************************************
  440           * PID_Direction 速度参数菜单（子菜单 2）
  441           *********************************************/
  442          void Menu_Speed_Show(uint8 control_line)
  443          {
  444   1          ips114_show_string(1 * 8, 0 * 18, "<<PID_SPEED");
  445   1      
  446   1          ips114_show_string(1 * 8, 1 * 18, "kp_Err");     // 位置误差比例系数
  447   1          ips114_show_string(1 * 8, 2 * 18, "kd_Err");     // 位置误差微分系数
  448   1          ips114_show_string(1 * 8, 3 * 18, "speed_run");  // 运行速度
  449   1          ips114_show_string(1 * 8, 4 * 18, "kd_gyro");    // 陀螺微分权重
  450   1          ips114_show_string(1 * 8, 5 * 18, "fuya_xili");  // 负压吸力
  451   1          ips114_show_string(1 * 8, 6 * 18, "pwm_filter"); // PWM 滤波
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 8   

  452   1      
  453   1          ips114_show_float(14 * 8, 1 * 18, kp_Err, 3, 3);
  454   1          ips114_show_float(14 * 8, 2 * 18, kd_Err, 3, 3);
  455   1          ips114_show_float(14 * 8, 3 * 18, speed_run, 3, 3);
  456   1          ips114_show_float(14 * 8, 4 * 18, kd_gyro, 3, 3);
  457   1          ips114_show_float(14 * 8, 5 * 18, fuya_xili, 4, 3);
  458   1          ips114_show_float(14 * 8, 6 * 18, pwm_filter, 3, 3);
  459   1      
  460   1          // 显示当前编辑标识
  461   1          if (control_line == 1)
  462   1          {
  463   2              ips114_show_string(0, control_line, " ");
  464   2          }
  465   1          else
  466   1          {
  467   2              ips114_show_string(0, control_line, "&");
  468   2          }
  469   1      }
  470          
  471          void Menu_Speed_Process(void)
  472          {
  473   1          switch (display_codename)
  474   1          {
  475   2          case 2: // PID_Direction 速度参数主菜单
  476   2              while (menu_next_flag == 0)
  477   2              {
  478   3                  Menu_Speed_Show(0);
  479   3                  Keystroke_Scan();
  480   3                  Cursor();
  481   3              }
  482   2              Menu_Next_Back();
  483   2              break;
  484   2      
  485   2          case 21: // 位置误差比例系数
  486   2              Menu_Speed_Show(1 * 18);
  487   2              Keystroke_float(&kp_Err, 0.01);
  488   2              break;
  489   2          case 22: // 位置误差微分系数
  490   2              Menu_Speed_Show(2 * 18);
  491   2              Keystroke_float(&kd_Err, 0.1);
  492   2              break;
  493   2          case 23: // 运行速度
  494   2              Menu_Speed_Show(3 * 18);
  495   2              Keystroke_float(&speed_run, 1);
  496   2              break;
  497   2          case 24: // 陀螺微分权重
  498   2              Menu_Speed_Show(4 * 18);
  499   2              Keystroke_float(&kd_gyro, 0.01);
  500   2              break;
  501   2          case 25: // 负压吸力
  502   2              Menu_Speed_Show(5 * 18);
  503   2              Keystroke_float(&fuya_xili, 100);
  504   2              break;
  505   2          case 26: // PWM 滤波
  506   2              Menu_Speed_Show(6 * 18);
  507   2              Keystroke_float(&pwm_filter, 0.1);
  508   2              break;
  509   2          }
  510   1      }
  511          
  512          /*********************************************
  513           * PID_Direction 角度参数菜单（子菜单 3）
  514           *********************************************/
  515          void Menu_Angle_Show(uint8 control_line)
  516          {
  517   1          ips114_show_string(1 * 8, 0 * 18, "<<PID_ANGLE");
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 9   

  518   1      
  519   1          ips114_show_string(1 * 8, 1 * 18, "kp_Angle");       // 角度比例系数
  520   1          ips114_show_string(1 * 8, 2 * 18, "kd_Angle");       // 角度微分系数
  521   1          ips114_show_string(1 * 8, 3 * 18, "limiting_Angle"); // 角度限幅
  522   1          ips114_show_string(1 * 8, 4 * 18, "A_1");            // 校正 A_1
  523   1          ips114_show_string(1 * 8, 5 * 18, "B_1");            // 校正 B_1
  524   1          ips114_show_string(1 * 8, 6 * 18, "C_l");            // 额外微调
  525   1      
  526   1          ips114_show_float(15 * 8, 1 * 18, kp_Angle, 3, 2);
  527   1          ips114_show_float(15 * 8, 2 * 18, kd_Angle, 3, 2);
  528   1          ips114_show_float(15 * 8, 3 * 18, limiting_Angle, 3, 2);
  529   1          ips114_show_float(14 * 8, 4 * 18, A_1, 3, 2);
  530   1          ips114_show_float(14 * 8, 5 * 18, B_1, 3, 2);
  531   1          ips114_show_float(14 * 8, 6 * 18, C_l, 3, 3);
  532   1      
  533   1          // 显示当前编辑标识
  534   1          if (control_line == 1)
  535   1          {
  536   2              ips114_show_string(0, control_line, " ");
  537   2          }
  538   1          else
  539   1          {
  540   2              ips114_show_string(0, control_line, "&");
  541   2          }
  542   1      }
  543          
  544          void Menu_Angle_Process(void)
  545          {
  546   1          switch (display_codename)
  547   1          {
  548   2          case 3: // PID_Direction 角度参数主菜单
  549   2              while (menu_next_flag == 0)
  550   2              {
  551   3                  Menu_Angle_Show(1);
  552   3                  Keystroke_Scan();
  553   3                  Cursor();
  554   3              }
  555   2              Menu_Next_Back();
  556   2              break;
  557   2      
  558   2          case 31: // 角度比例系数
  559   2              Menu_Angle_Show(1 * 18);
  560   2              Keystroke_float(&kp_Angle, 0.01);
  561   2              break;
  562   2          case 32: // 角度微分系数
  563   2              Menu_Angle_Show(2 * 18);
  564   2              Keystroke_float(&kd_Angle, 0.01);
  565   2              break;
  566   2          case 33: // 角度限幅
  567   2              Menu_Angle_Show(3 * 18);
  568   2              Keystroke_float(&limiting_Angle, 10);
  569   2              break;
  570   2          case 34: // 校正 A_1
  571   2              Menu_Angle_Show(4 * 18);
  572   2              Keystroke_float(&A_1, 0.01);
  573   2              break;
  574   2          case 35: // 校正 B_1
  575   2              Menu_Angle_Show(5 * 18);
  576   2              Keystroke_float(&B_1, 0.01);
  577   2              break;
  578   2          case 36: // 额外微调
  579   2              Menu_Angle_Show(6 * 18);
  580   2              Keystroke_float(&C_l, 0.01);
  581   2              break;
  582   2          }
  583   1      }
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 10  

  584          
  585          /*********************************************
  586           * 传感器显示菜单（子菜单 4）
  587           *********************************************/
  588          void Menu_Sensor_Show(void)
  589          {
  590   1          // 显示赛道的标签（依次为 ad1..ad4）
  591   1          ips114_show_string(1 * 14, 18 * 0, "ad1"); // 左前
  592   1          ips114_show_string(1 * 14, 18 * 1, "ad2"); // 左后
  593   1          ips114_show_string(1 * 14, 18 * 3, "ad3"); // 右前
  594   1          ips114_show_string(1 * 14, 18 * 5, "ad4"); // 右后
  595   1      
  596   1          // 显示当前值（0-100），使用整数显示
  597   1          ips114_show_int32(14 * 4, 18 * 0, ad1, 3);
  598   1          ips114_show_int32(14 * 4, 18 * 1, ad2, 3);
  599   1          ips114_show_int32(14 * 4, 18 * 3, ad3, 3);
  600   1          ips114_show_int32(14 * 4, 18 * 5, ad4, 3);
  601   1      
  602   1          // 显示标定最大值（整数显示供参考）
  603   1          ips114_show_int32(14 * 8, 18 * 0, MA[0], 5); // ad1 最大值
  604   1          ips114_show_int32(14 * 8, 18 * 1, MA[1], 5); // ad2 最大值
  605   1          ips114_show_int32(14 * 8, 18 * 2, MA[2], 5); // ad3 最大值
  606   1          ips114_show_int32(14 * 8, 18 * 3, MA[3], 5); // ad4 最大值
  607   1      }
  608          
  609          void Menu_Sensor_Process(void)
  610          {
  611   1          switch (display_codename)
  612   1          {
  613   2          case 4:
  614   2              while (menu_next_flag == 0)
  615   2              {
  616   3                  Menu_Sensor_Show();
  617   3                  Keystroke_Scan();
  618   3                  Cursor();
  619   3              }
  620   2              Menu_Next_Back();
  621   2              break;
  622   2          }
  623   1      }
  624          /*********************************************
  625           * 圆环控制参数菜单（子菜单 5）
  626           *********************************************/
  627          void Menu_Circle_Show(uint8 control_line)
  628          {
  629   1          ips114_show_string(1 * 8, 0 * 18, "<<RING_CTRL");
  630   1      
  631   1          ips114_show_string(1 * 8, 1 * 18, "ring_en"); // 圆环编码器开关值
  632   1          ips114_show_string(1 * 8, 2 * 18, "p_r_G");   // 入环前陀螺设定值
  633   1          ips114_show_string(1 * 8, 3 * 18, "i_r_G");   // 入环陀螺 Z 轴值
  634   1          ips114_show_string(1 * 8, 4 * 18, "p_o_G");   // 出环前陀螺设定值
  635   1          ips114_show_string(1 * 8, 5 * 18, "p_o__G");  // 出环前陀螺 Z 值
  636   1          ips114_show_string(1 * 8, 6 * 18, "p_o_en");  // 出环编码器开关值
  637   1      
  638   1          ips114_show_float(14 * 8, 1 * 18, ring_encoder, 3, 2);
  639   1          ips114_show_float(14 * 8, 2 * 18, pre_ring_Gyro_set, 3, 2);
  640   1          ips114_show_float(14 * 8, 3 * 18, in_ring_Gyroz, 3, 2);
  641   1          ips114_show_float(14 * 8, 4 * 18, pre_out_ring_Gyro_set, 3, 2);
  642   1          ips114_show_float(14 * 8, 5 * 18, pre_out_ring_Gyroz, 3, 2);
  643   1          ips114_show_float(14 * 8, 6 * 18, pre_out_ring_encoder, 3, 2);
  644   1      
  645   1          // 显示当前编辑标识
  646   1          if (control_line == 1)
  647   1          {
  648   2              ips114_show_string(0, control_line, " ");
  649   2          }
C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 11  

  650   1          else
  651   1          {
  652   2              ips114_show_string(0, control_line, "&");
  653   2          }
  654   1      }
  655          
  656          void Menu_Circle_Process(void)
  657          {
  658   1          switch (display_codename)
  659   1          {
  660   2          case 5: // 圆环控制参数主菜单
  661   2              while (menu_next_flag == 0)
  662   2              {
  663   3                  Menu_Circle_Show(1);
  664   3                  Keystroke_Scan();
  665   3                  Cursor();
  666   3              }
  667   2              Menu_Next_Back();
  668   2              break;
  669   2      
  670   2          case 51: // 圆环编码器开关值
  671   2              Menu_Circle_Show(1 * 18);
  672   2              Keystroke_float(&ring_encoder, 1);
  673   2              break;
  674   2          case 52: // 入环前陀螺设定值
  675   2              Menu_Circle_Show(2 * 18);
  676   2              Keystroke_float(&pre_ring_Gyro_set, 10);
  677   2              break;
  678   2          case 53: // 入环陀螺 Z 轴值
  679   2              Menu_Circle_Show(3 * 18);
  680   2              Keystroke_float(&in_ring_Gyroz, 10);
  681   2              break;
  682   2          case 54: // 出环前陀螺设定值
  683   2              Menu_Circle_Show(4 * 18);
  684   2              Keystroke_float(&pre_out_ring_Gyro_set, 10);
  685   2              break;
  686   2          case 55: // 出环前陀螺 Z 值
  687   2              Menu_Circle_Show(5 * 18);
  688   2              Keystroke_float(&pre_out_ring_Gyroz, 10);
  689   2              break;
  690   2          case 56: // 出环编码器开关值
  691   2              Menu_Circle_Show(6 * 18);
  692   2              Keystroke_float(&pre_out_ring_encoder, 1);
  693   2              break;
  694   2          }
  695   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4519     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       116     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       798     ------
End of Module Information.

C251 COMPILER V5.60.0,  menu                                                               26/11/25  15:19:33  PAGE 12  


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
