C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE vofa
OBJECT MODULE PLACED IN .\out_file\vofa.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\vofa.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\vofa.lst) OBJECT(.\out_file\vofa.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #include "vofa.h"
    3          #include <stdlib.h>
    4          
    5          // VOFA 数据对象
    6          static vofa_data_struct vofa_data;
    7          
    8          // 内部函数声明
    9          static void vofa_parse_byte(uint8 dat);
   10          
   11          //-------------------------------------------------------------------------------------------------------
             -------------
   12          // 函数简介     VOFA+ 初始化
   13          // 参数说明     void
   14          // 返回参数     void
   15          // 使用示例     vofa_init();
   16          // 备注信息     初始化 VOFA 数据结构（无需额外操作，使用系统自带 FIFO）
   17          //-------------------------------------------------------------------------------------------------------
             -------------
   18          void vofa_init(void)
   19          {
   20   1              uint8 i;
   21   1      
   22   1              // 清空缓冲区
   23   1              for (i = 0; i < VOFA_BUFFER_SIZE; i++)
   24   1              {
   25   2                      vofa_data.buffer[i] = 0;
   26   2              }
   27   1      
   28   1              for (i = 0; i < VOFA_MAX_CMD_LEN; i++)
   29   1              {
   30   2                      vofa_data.cmd_buffer[i] = 0;
   31   2              }
   32   1      
   33   1              vofa_data.index = 0;
   34   1              vofa_data.cmd_len = 0;
   35   1              vofa_data.state = VOFA_PARSE_IDLE;
   36   1      }
   37          
   38          //-------------------------------------------------------------------------------------------------------
             -------------
   39          // 函数简介     VOFA+ FireWater 协议从 FIFO 读取并解析数据
   40          // 参数说明     void
   41          // 返回参数     void
   42          // 使用示例     vofa_parse_from_fifo();  // 在主循环中调用
   43          // 备注信息     FireWater 协议: 以 '!' (0x21) 作为帧尾标识
   44          //              直接使用 wireless_uart_read_buffer() 从 FIFO 读取数据
   45          //-------------------------------------------------------------------------------------------------------
             -------------
   46          void vofa_parse_from_fifo(void)
   47          {
   48   1              uint8 dat;
   49   1      
   50   1              // 从 FIFO 读取数据（使用系统自带函数）
   51   1              while (wireless_uart_read_buffer(&dat, 1) > 0)
   52   1              {
   53   2                      vofa_parse_byte(dat);
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 2   

   54   2              }
   55   1      }
   56          
   57          //-------------------------------------------------------------------------------------------------------
             -------------
   58          // 函数简介     VOFA+ FireWater 协议解析单个字节（内部函数）
   59          // 参数说明     dat             接收到的字节数据
   60          // 返回参数     void
   61          // 使用示例     vofa_parse_byte(0x50);
   62          // 备注信息     FireWater 协议: 以 '!' (0x21) 作为帧尾标识
   63          //              例如: "PR=2.32!" 会被解析为完整命令
   64          //-------------------------------------------------------------------------------------------------------
             -------------
   65          static void vofa_parse_byte(uint8 dat)
   66          {
   67   1              // 检测到帧尾标识 '!' (ASCII: 0x21 即十进制 33)
   68   1              if (dat == '!' || dat == 0x21)
   69   1              {
   70   2                      if (vofa_data.index > 0)
   71   2                      {
   72   3                              // 添加字符串结束符
   73   3                              vofa_data.buffer[vofa_data.index] = '\0';
   74   3      
   75   3                              // 复制到命令缓冲区
   76   3                              memcpy(vofa_data.cmd_buffer, vofa_data.buffer, vofa_data.index + 1);
   77   3                              vofa_data.cmd_len = vofa_data.index;
   78   3      
   79   3                              // 标记解析完成
   80   3                              vofa_data.state = VOFA_PARSE_COMPLETE;
   81   3      
   82   3                              // 重置索引
   83   3                              vofa_data.index = 0;
   84   3                      }
   85   2              }
   86   1              else
   87   1              {
   88   2                      // 接收数据
   89   2                      if (vofa_data.index < VOFA_BUFFER_SIZE - 1)
   90   2                      {
   91   3                              vofa_data.buffer[vofa_data.index++] = dat;
   92   3                              vofa_data.state = VOFA_PARSE_RECEIVING;
   93   3                      }
   94   2                      else
   95   2                      {
   96   3                              // 缓冲区溢出，重置
   97   3                              vofa_data.index = 0;
   98   3                              vofa_data.state = VOFA_PARSE_IDLE;
   99   3                      }
  100   2              }
  101   1      }
  102          
  103          //-------------------------------------------------------------------------------------------------------
             -------------
  104          // 函数简介     获取 VOFA+ 接收到的完整命令
  105          // 参数说明     cmd_out         输出命令字符串的缓冲区
  106          // 参数说明     max_len         缓冲区最大长度
  107          // 返回参数     uint8           1-有新命令 0-无新命令
  108          // 使用示例     char cmd[32];
  109          //              if(vofa_get_command(cmd, 32)) {
  110          //                  // 处理命令
  111          //              }
  112          // 备注信息     获取命令后会自动清除完成标志
  113          //-------------------------------------------------------------------------------------------------------
             -------------
  114          uint8 vofa_get_command(char *cmd_out, uint8 max_len)
  115          {
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 3   

  116   1              uint8 result = 0;
  117   1      
  118   1              if (vofa_data.state == VOFA_PARSE_COMPLETE)
  119   1              {
  120   2                      // 复制命令
  121   2                      if (vofa_data.cmd_len < max_len)
  122   2                      {
  123   3                              memcpy(cmd_out, vofa_data.cmd_buffer, vofa_data.cmd_len + 1);
  124   3                              result = 1;
  125   3                      }
  126   2      
  127   2                      // 清除完成标志
  128   2                      vofa_data.state = VOFA_PARSE_IDLE;
  129   2                      vofa_data.cmd_len = 0;
  130   2              }
  131   1      
  132   1              return result;
  133   1      }
  134          
  135          //-------------------------------------------------------------------------------------------------------
             -------------
  136          // 函数简介     清空 VOFA 接收缓冲区
  137          // 参数说明     void
  138          // 返回参数     void
  139          // 使用示例     vofa_clear_buffer();
  140          // 备注信息     在出现接收错误时可以调用此函数清空缓冲区
  141          //-------------------------------------------------------------------------------------------------------
             -------------
  142          void vofa_clear_buffer(void)
  143          {
  144   1              vofa_data.index = 0;
  145   1              vofa_data.cmd_len = 0;
  146   1              vofa_data.state = VOFA_PARSE_IDLE;
  147   1      }
  148          
  149          //-------------------------------------------------------------------------------------------------------
             -------------
  150          // 函数简介     VOFA+ FireWater 协议命令解析示例
  151          // 参数说明     cmd             接收到的命令字符串
  152          // 返回参数     void
  153          // 使用示例     vofa_parse_command("PR=2.32");
  154          // 备注信息     示例函数，展示如何解析不同格式的命令
  155          //              格式1: "PR=2.32"  - 解析参数名和浮点数值
  156          //              格式2: "SPEED=100" - 解析参数名和整数值
  157          //              格式3: "START" - 单独的命令
  158          //-------------------------------------------------------------------------------------------------------
             -------------
  159          void vofa_parse_command(char *cmd)
  160          {
  161   1              char *eq_pos;
  162   1              char param_name[16];
  163   1              float param_value;
  164   1              uint8 name_len;
  165   1              uint8 i;
  166   1      
  167   1              // 初始化变量
  168   1              for (i = 0; i < 16; i++)
  169   1              {
  170   2                      param_name[i] = 0;
  171   2              }
  172   1              param_value = 0.0;
  173   1      
  174   1              // 查找等号位置
  175   1              eq_pos = strchr(cmd, '=');
  176   1      
  177   1              if (eq_pos != NULL)
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 4   

  178   1              {
  179   2                      // 有等号，说明是参数设置命令
  180   2                      name_len = (uint8)(eq_pos - cmd);
  181   2      
  182   2                      if (name_len < 16)
  183   2                      {
  184   3                              // 提取参数名
  185   3                              memcpy(param_name, cmd, name_len);
  186   3                              param_name[name_len] = '\0';
  187   3      
  188   3                              // 提取参数值
  189   3                              param_value = atof(eq_pos + 1);
  190   3      
  191   3                              // 根据参数名执行不同操作
  192   3                              if (strcmp(param_name, "PR") == 0)
  193   3                              {
  194   4                                      // 处理 PR 参数
  195   4                                      printf("Received PR = %.2f\n", param_value);
  196   4                                      // 在这里添加你的处理代码
  197   4                              }
  198   3                              else if (strcmp(param_name, "SPEED") == 0)
  199   3                              {
  200   4                                      // 处理 SPEED 参数
  201   4                                      printf("Received SPEED = %.2f\n", param_value);
  202   4                              }
  203   3                              else if (strcmp(param_name, "KP") == 0)
  204   3                              {
  205   4                                      // 处理 KP 参数（PID_Direction参数）
  206   4                                      printf("Received KP = %.2f\n", param_value);
  207   4                              }
  208   3                              else if (strcmp(param_name, "KI") == 0)
  209   3                              {
  210   4                                      // 处理 KI 参数
  211   4                                      printf("Received KI = %.2f\n", param_value);
  212   4                              }
  213   3                              else if (strcmp(param_name, "KD") == 0)
  214   3                              {
  215   4                                      // 处理 KD 参数
  216   4                                      printf("Received KD = %.2f\n", param_value);
  217   4                              }
  218   3                      }
  219   2              }
  220   1              else
  221   1              {
  222   2                      // 无等号，说明是单独的命令
  223   2                      if (strcmp(cmd, "START") == 0)
  224   2                      {
  225   3                              printf("Received START command\n");
  226   3                              // 执行启动操作
  227   3                      }
  228   2                      else if (strcmp(cmd, "STOP") == 0)
  229   2                      {
  230   3                              printf("Received STOP command\n");
  231   3                              // 执行停止操作
  232   3                      }
  233   2                      else if (strcmp(cmd, "RESET") == 0)
  234   2                      {
  235   3                              printf("Received RESET command\n");
  236   3                              // 执行复位操作
  237   3                      }
  238   2              }
  239   1      }
  240          
  241          //-------------------------------------------------------------------------------------------------------
             -------------
  242          // 函数功能     处理 VOFA+ 接收到的命令
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 5   

  243          // 参数说明     cmd         接收到的命令字符串
  244          // 返回参数     void
  245          // 使用示例     handle_vofa_command("KP=1.5");
  246          //-------------------------------------------------------------------------------------------------------
             -------------
  247          void handle_vofa_command(char *cmd)
  248          {
  249   1              char *eq_pos;
  250   1              char param_name[16];
  251   1              uint8 name_len;
  252   1              float value;
  253   1              uint8 i;
  254   1      
  255   1              // 初始化临时变量
  256   1              for (i = 0; i < 16; i++)
  257   1              {
  258   2                      param_name[i] = 0;
  259   2              }
  260   1      
  261   1              eq_pos = strchr(cmd, '=');
  262   1      
  263   1              if (eq_pos != NULL)
  264   1              {
  265   2                      // ========== 处理带参数的命令 ==========
  266   2                      name_len = (uint8)(eq_pos - cmd);
  267   2      
  268   2                      if (name_len < 16)
  269   2                      {
  270   3                              // 读取参数名
  271   3                              memcpy(param_name, cmd, name_len);
  272   3                              param_name[name_len] = '\0';
  273   3      
  274   3                              // 读取参数值
  275   3                              value = atof(eq_pos + 1);
  276   3      
  277   3                              // ========== 左轮速度环 PID_Direction 参数 ==========
  278   3                              if (strcmp(param_name, "L_KP") == 0)
  279   3                              {
  280   4                                      PID.left_speed.Kp = value;
  281   4                                      printf("Left Kp = %.2f\n", value);
  282   4                                      ips114_show_float(1 * 24, 18 * 0, value, 3, 2);
  283   4                              }
  284   3                              else if (strcmp(param_name, "L_KI") == 0)
  285   3                              {
  286   4                                      PID.left_speed.Ki = value;
  287   4                                      printf("Left Ki = %.2f\n", value);
  288   4                              }
  289   3                              else if (strcmp(param_name, "L_KD") == 0)
  290   3                              {
  291   4                                      PID.left_speed.Kd = value;
  292   4                                      printf("Left Kd = %.2f\n", value);
  293   4                              }
  294   3      
  295   3                              // ========== 右轮速度环 PID_Direction 参数 ==========
  296   3                              else if (strcmp(param_name, "R_KP") == 0)
  297   3                              {
  298   4                                      PID.right_speed.Kp = value;
  299   4                                      printf("Right Kp = %.2f\n", value);
  300   4                              }
  301   3                              else if (strcmp(param_name, "R_KI") == 0)
  302   3                              {
  303   4                                      PID.right_speed.Ki = value;
  304   4                                      printf("Right Ki = %.2f\n", value);
  305   4                              }
  306   3                              else if (strcmp(param_name, "R_KD") == 0)
  307   3                              {
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 6   

  308   4                                      PID.right_speed.Kd = value;
  309   4                                      printf("Right Kd = %.2f\n", value);
  310   4                              }
  311   3      
  312   3                              // ========== 转向环（位置式）PID_Direction 参数 ==========
  313   3                              else if (strcmp(param_name, "P_KP") == 0)
  314   3                              {
  315   4                                      PID.steer.Kp = value;
  316   4                                      kp_Err = value; // 同步到位置误差 Kp（用于菜单显示）
  317   4                                      printf("Position Kp = %.2f\n", value);
  318   4                              }
  319   3                              else if (strcmp(param_name, "P_KI") == 0)
  320   3                              {
  321   4                                      // 兼容旧命令：将位置式的 Ki 映射为 kd_gyro
  322   4                                      kd_gyro = value;
  323   4                                      PID.steer.kd_gyro = value;
  324   4                                      printf("Position kd_gyro (from Ki) = %.2f\n", value);
  325   4                              }
  326   3                              else if (strcmp(param_name, "P_KD") == 0)
  327   3                              {
  328   4                                      PID.steer.Kd = value;
  329   4                                      kd_Err = value; // 同步到位置误差 Kd（用于菜单显示）
  330   4                                      printf("Position Kd = %.2f\n", value);
  331   4                              }
  332   3                              else if (strcmp(param_name, "KD_GYRO") == 0)
  333   3                              {
  334   4                                      kd_gyro = value;
  335   4                                      PID.steer.kd_gyro = value; // 角速度微分权重系数
  336   4                                      printf("Kd Gyro = %.2f\n", value);
  337   4                              }
  338   3      
  339   3                              // ========== 速度控制 ==========
  340   3                              else if (strcmp(param_name, "SPEED") == 0)
  341   3                              {
  342   4                                      test_speed = value;
  343   4                                      printf("Target Speed = %.2f\n", value);
  344   4                              }
  345   3                              else if (strcmp(param_name, "RP") == 0)
  346   3                              {
  347   4                                      // RP 为占位命令，可按业务需要修改映射
  348   4                                      test_speed = value; // 示例：将其映射为测试速度
  349   4                                      printf("RP = %.2f\n", value);
  350   4                              }
  351   3                              else if (strcmp(param_name, "MOTOR") == 0)
  352   3                              {
  353   4                                      // 显示/调试用途：映射到位置式 PID_Direction 输出
  354   4                                      PID.steer.output = value;
  355   4                                      printf("Motor = %.2f\n", value);
  356   4                              }
  357   3                              else if (strcmp(param_name, "SPEED_RUN") == 0)
  358   3                              {
  359   4                                      speed_run = value;
  360   4                                      printf("Speed Run = %.2f\n", value);
  361   4                              }
  362   3      
  363   3                              // ========== 误差（兼容外部注入） ==========
  364   3                              else if (strcmp(param_name, "ERR") == 0)
  365   3                              {
  366   4                                      Err = value;
  367   4                                      printf("Error = %.2f\n", value);
  368   4                              }
  369   3                              else
  370   3                              {
  371   4                                      printf("Unknown parameter: %s = %.2f\n", param_name, value);
  372   4                              }
  373   3                      }
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 7   

  374   2              }
  375   1              else
  376   1              {
  377   2                      // ========== 处理无参数的命令 ==========
  378   2                      if (strcmp(cmd, "START") == 0)
  379   2                      {
  380   3                              // 启动电机
  381   3                              printf("Motor START\n");
  382   3                              // 可在此设置运行标志位
  383   3                      }
  384   2                      else if (strcmp(cmd, "STOP") == 0)
  385   2                      {
  386   3                              // 停止电机：清零转向环输出与运行速度
  387   3                              PID.steer.output = 0;
  388   3                              speed_run = 0;
  389   3                              test_speed = 0;
  390   3                              printf("Motor STOP\n");
  391   3                      }
  392   2                      else if (strcmp(cmd, "RESET") == 0)
  393   2                      {
  394   3                              // 软复位系统
  395   3                              IAP_CONTR = 0x60; // 触发软复位
  396   3                      }
  397   2                      else if (strcmp(cmd, "SAVE") == 0)
  398   2                      {
  399   3                              // 保存参数到 EEPROM
  400   3                              eeprom_flash();
  401   3                              printf("Parameters saved\n");
  402   3                      }
  403   2                      else if (strcmp(cmd, "LOAD") == 0)
  404   2                      {
  405   3                              // 从 EEPROM 加载参数
  406   3                              eeprom_init();
  407   3                              printf("Parameters loaded\n");
  408   3                      }
  409   2                      else if (strcmp(cmd, "INFO") == 0)
  410   2                      {
  411   3                              // 打印当前参数信息
  412   3                              printf("=== Current Parameters ===\n");
  413   3                              printf("Left PID_Direction: %.2f, %.2f, %.2f\n",
  414   3                                         PID.left_speed.Kp,
  415   3                                         PID.left_speed.Ki,
  416   3                                         PID.left_speed.Kd);
  417   3                              printf("Right PID_Direction: %.2f, %.2f, %.2f\n",
  418   3                                         PID.right_speed.Kp,
  419   3                                         PID.right_speed.Ki,
  420   3                                         PID.right_speed.Kd);
  421   3                              printf("Speed: %.2f\n", test_speed);
  422   3                      }
  423   2                      else
  424   2                      {
  425   3                              printf("Unknown command: %s\n", cmd);
  426   3                      }
  427   2              }
  428   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3486     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       169     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
C251 COMPILER V5.60.0,  vofa                                                               22/11/25  23:09:31  PAGE 8   

  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       799     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
