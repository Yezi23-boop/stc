C251 COMPILER V5.60.0,  imu                                                                26/11/25  15:19:34  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE imu
OBJECT MODULE PLACED IN .\out_file\imu.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\user\imu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\imu.lst) TABS(2) OBJECT(.\out_file\imu.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #include "math.h"
    3          // 姿态融合 PI 参数（Mahony/Madgwick 思想的简化实现）
    4          // Kp：比例增益，越大对加速度（重力方向）校正越强，收敛快但易抖
    5          // Ki：积分增益，用于补偿陀螺零偏；过大易积累误差，过小收敛慢
    6          #define Kp 5.0f
    7          #define Ki 0.007f
    8          
    9          // halfT：半采样周期（即 0.5 * Ts）。若你的传感器更新周期为 5ms，则 halfT = 0.0025f
   10          #define halfT 0.005f
   11          
   12          // 部分工具函数需要圆周率，若 math.h 未定义 M_PI 则手动给出
   13          #define M_PI 3.1415926535
   14          
   15          // 全局姿态角与传感器滤波输出（单位：角度为度，角速度/加速度见下）
   16          // 结构体 FLOAT_ANGLE、FLOAT_XYZ 由库中头文件定义
   17          FLOAT_ANGLE Att_Angle; // roll/pitch/yaw（单位：度）
   18          FLOAT_XYZ Acc_filt;    // 滤波后的加速度
   19          FLOAT_XYZ Gyr_filt;    // 滤波后的角速度（单位：弧度每秒）
   20          
   21          // 说明：有些平台不提供 atan2，这里自写一个等价函数
   22          // 输入 (y, x)，返回区分象限的反正切角（单位：弧度）
   23          double my_atan2(double y, double x)
   24          {
   25   1          // 处理 x == 0 的退化情况，避免除零
   26   1          if (x == 0)
   27   1          {
   28   2              if (y > 0)
   29   2                  return M_PI / 2; // +90°
   30   2              else if (y < 0)
   31   2                  return -M_PI / 2; // -90°
   32   2              else
   33   2                  return 0; // 原点
   34   2          }
   35   1          else
   36   1          {
   37   2              // 计算基础角度
   38   2              double theta = atan(y / x);
   39   2      
   40   2              // 根据 x 符号修正到正确象限
   41   2              if (x > 0)
   42   2              {
   43   3                  // 第一、四象限
   44   3                  return theta;
   45   3              }
   46   2              else
   47   2              {
   48   3                  // x < 0：第二、三象限
   49   3                  if (y >= 0)
   50   3                      return theta + M_PI;
   51   3                  else
   52   3                      return theta - M_PI;
   53   3              }
   54   2          }
   55   1      }
   56          
   57          // 传感器数据预处理：读取原始 IMU 数据，做单位转换与零偏校正
C251 COMPILER V5.60.0,  imu                                                                26/11/25  15:19:34  PAGE 2   

   58          // 依赖外部 API：imu660ra_get_acc / imu660ra_get_gyro / *_transition()
   59          // 依赖外部常量：Gyro_offset_x/y/z、DegtoRad
   60          void Prepare_Data(void)
   61          {
   62   1          // 读取一次原始数据（驱动内部会更新 imu660ra_* 全局变量）
   63   1          imu660ra_get_acc();
   64   1          imu660ra_get_gyro();
   65   1      
   66   1          // 陀螺（单位：弧度每秒）= (原始度每秒 - 零偏) × 度转弧度
   67   1          Gyr_filt.X = (imu660ra_gyro_transition(imu660ra_gyro_x) - Gyro_offset_x) * DegtoRad;
   68   1          Gyr_filt.Y = (imu660ra_gyro_transition(imu660ra_gyro_y) - Gyro_offset_y) * DegtoRad;
   69   1          Gyr_filt.Z = (imu660ra_gyro_transition(imu660ra_gyro_z) - Gyro_offset_z) * DegtoRad;
   70   1      
   71   1          // 加速度（单位：按驱动转换结果，通常为 g 或 m/s^2）
   72   1          Acc_filt.X = imu660ra_acc_transition(imu660ra_acc_x) - acc_offset_x;
   73   1          Acc_filt.Y = imu660ra_acc_transition(imu660ra_acc_y) - acc_offset_y;
   74   1          Acc_filt.Z = imu660ra_acc_transition(imu660ra_acc_z);
   75   1      }
   76          
   77          // 四元数（单位四元数，用于描述机体姿态，q0 为标量部）
   78          float q0 = 1, q1 = 0, q2 = 0, q3 = 0;
   79          
   80          // 中间量（方向余弦估计、误差项、模长等）
   81          float vx, vy, vz, ex, ey, ez, norm;
   82          
   83          // 快速 1/sqrt(x) 前置声明（位运算近似）
   84          static float invSqrt(float x);
   85          
   86          // 核心姿态更新：基于陀螺积分 + 加速度方向反馈
   87          // Gyr_rad：角速度（弧度/秒）
   88          // Acc_filt：加速度（方向用于估计重力）
   89          // Att_Angle：输出欧拉角（度）
   90          void IMUupdate(FLOAT_XYZ *Gyr_rad, FLOAT_XYZ *Acc_filt, FLOAT_ANGLE *Att_Angle)
   91          {
   92   1          // 读取输入（为减少解引用次数）
   93   1          float ax = Acc_filt->X, ay = Acc_filt->Y, az = Acc_filt->Z;
   94   1          float gx = Gyr_rad->X, gy = Gyr_rad->Y, gz = Gyr_rad->Z;
   95   1      
   96   1          // 陀螺零偏的积分估计项（PI 控制中的 I）
   97   1          static float exInt = 0, eyInt = 0, ezInt = 0;
   98   1      
   99   1          // 保存旧四元数（欧拉步进）
  100   1          float q0_old = 0, q1_old = 0, q2_old = 0, q3_old = 0;
  101   1      
  102   1          // 1) 将加速度归一化，作为重力方向观测
  103   1          norm = invSqrt(ax * ax + ay * ay + az * az); // 1/sqrt(a・a)
  104   1          ax *= norm;
  105   1          ay *= norm;
  106   1          az *= norm;
  107   1      
  108   1          // 2) 根据当前四元数估计机体坐标系下的重力方向 v = R*[0,0,1]
  109   1          // 公式推导自方向余弦矩阵与四元数的关系
  110   1          vx = 2 * (q1 * q3 - q0 * q2);
  111   1          vy = 2 * (q0 * q1 + q2 * q3);
  112   1          vz = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;
  113   1      
  114   1          // 3) 计算重力方向误差 e = a × v
  115   1          //   当机体静止或匀速运动时，a ≈ 重力方向；叉积得到方向误差
  116   1          ex = (ay * vz - az * vy);
  117   1          ey = (az * vx - ax * vz);
  118   1          ez = (ax * vy - ay * vx);
  119   1      
  120   1          // 4) 误差积分（I 项），用于补偿陀螺零偏
  121   1          exInt += ex * Ki;
  122   1          eyInt += ey * Ki;
  123   1          ezInt += ez * Ki;
C251 COMPILER V5.60.0,  imu                                                                26/11/25  15:19:34  PAGE 3   

  124   1      
  125   1          // 5) 将比例 + 积分误差反馈到陀螺，形成 PI 闭环
  126   1          gx += Kp * ex + exInt;
  127   1          gy += Kp * ey + eyInt;
  128   1          gz += Kp * ez + ezInt;
  129   1      
  130   1          // 6) 四元数微分积分（离散欧拉积分，采样周期 Ts=2*halfT）
  131   1          q0_old = q0;
  132   1          q1_old = q1;
  133   1          q2_old = q2;
  134   1          q3_old = q3;
  135   1      
  136   1          // q_dot = 0.5 * q ? [0, gx, gy, gz]
  137   1          // 这里用 halfT 已包含 0.5*Ts 的因子，因此直接累加
  138   1          q0 += (-q1_old * gx - q2_old * gy - q3_old * gz) * halfT;
  139   1          q1 += (q0_old * gx + q2_old * gz - q3_old * gy) * halfT;
  140   1          q2 += (q0_old * gy - q1_old * gz + q3_old * gx) * halfT;
  141   1          q3 += (q0_old * gz + q1_old * gy - q2_old * gx) * halfT;
  142   1      
  143   1          // 7) 归一化四元数，抑制数值漂移
  144   1          norm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
  145   1          q0 *= norm;
  146   1          q1 *= norm;
  147   1          q2 *= norm;
  148   1          q3 *= norm;
  149   1      
  150   1          // 8) 四元数转欧拉角（Z-Y-X，航向-俯仰-横滚）
  151   1          // 角度转换为“度”
  152   1          //    Att_Angle->rol = (float)(my_atan2(2 * (q0 * q1 + q2 * q3), 1 - 2 * (q1 * q1 + q2 * q2)) * Radto
             -Deg);
  153   1          //    Att_Angle->pit = (float)(asin(2 * (q0 * q2 - q1 * q3)) * RadtoDeg);
  154   1          // 航向（yaw）若无磁力计参与，可直接用陀螺积分近似更新（对漂移较敏感）
  155   1          // 这里做了小阈值抑制：角速度过小认为是噪声，不更新 yaw
  156   1          if ((Gyr_rad->Z * RadtoDeg > 1.0f) || (Gyr_rad->Z * RadtoDeg < -1.0f))
  157   1          {
  158   2              // 0.01f ≈ 积分步长（单位：秒）。若你的真实采样周期不是 10ms，请等比例调整
  159   2              Att_Angle->yaw += Gyr_rad->Z * RadtoDeg * 0.01f;
  160   2          }
  161   1      }
  162          
  163          // 快速求 1/sqrt(x) 的近似算法（Quake fast inverse sqrt）
  164          // 误差很小，速度很快；如需更高精度可再迭代一次牛顿法
  165          static float invSqrt(float x)
  166          {
  167   1          float halfx = 0.5f * x;
  168   1          float y = x;
  169   1          long i = *(long *)&y;             // 将 float 按位解释为整数
  170   1          i = 0x5f375a86 - (i >> 1);        // 魔数初始近似
  171   1          y = *(float *)&i;                 // 按位解释回 float
  172   1          y = y * (1.5f - (halfx * y * y)); // 牛顿迭代一步
  173   1          return y;
  174   1      }
  175          
  176          float SquareRootFloat(float number)
  177          {
  178   1          long i;
  179   1          float x, y;
  180   1          const float f = 1.5F;
  181   1      
  182   1          x = number * 0.5F;
  183   1          y = number;
  184   1          i = *(long *)&y;
  185   1          i = 0x5f3759df - (i >> 1); // 卡马克
  186   1          //   i  = 0x5f375a86 - ( i >> 1 );  //Lomont
  187   1          y = *(float *)&i;
  188   1          y = y * (f - (x * y * y));
C251 COMPILER V5.60.0,  imu                                                                26/11/25  15:19:34  PAGE 4   

  189   1          y = y * (f - (x * y * y));
  190   1          return number * y;
  191   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3386     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       204     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        63     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
