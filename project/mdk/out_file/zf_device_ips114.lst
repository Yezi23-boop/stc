C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_ips114
OBJECT MODULE PLACED IN .\out_file\zf_device_ips114.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_ips114.c LARGE NOALIAS FLOAT64 WARN
                    -INGLEVEL(3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_de
                    -vice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_ips114.lst) OBJECT(.\out_file\zf_device
                    -_ips114.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * AI8051U Opensource Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3           * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4           *
    5           * ±¾ÎÄ¼þÊÇ STC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6           *
    7           * AI8051U ¿ªÔ´¿â ÎªÃâ·ÑÈí¼þ
    8           * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£©Ìõ¿î
    9           * ¼´ GPL3.0 »ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10           *
   11           * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎ±£Ö¤
   12           * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13           * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14           * Ðí¿ÉÖ¤¸±±¾Î»ÓÚ libraries Ä¿Â¼ÏÂµÄ LICENSE ÎÄ¼þ
   15           *
   16           * ÎÄ¼þÃû³Æ        zf_device_ips114.c
   17           * ¹«Ë¾Ãû³Æ        ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   18           * °æ±¾ÐÅÏ¢        ²é¿´ libraries/doc Ä¿Â¼ÄÚ version.txt
   19           * ¿ª·¢»·¾³        MDK FOR C251
   20           * ÊÊÓÃÆ½Ì¨        AI8051U
   21           * µêÆÌÁ´½Ó        https://seekfree.taobao.com/
   22           *
   23           * ÐÞ¸Ä¼ÇÂ¼
   24           * ÈÕÆÚ            ×÷Õß           ±¸×¢
   25           * 2024-08-01      ´óW            Í³Ò»ÎÄ¼þÍ·×¢ÊÍ£¬ÐÞ¸´ÖÐÎÄÂÒÂë
   26           ********************************************************************************************************
             -************/
   27          /********************************************************************************************************
             -*************
   28           * ½ÓÏß¶¨Òå£º
   29           *                   ------------------------------------
   30           *                   Ä£¿é¹Ü½Å             µ¥Æ¬»ú¹Ü½Å
   31           *                   SCL                  ²é¿´ zf_device_ips114.h ÖÐ IPS114_SCL_PIN ºê¶¨Òå
   32           *                   SDA                  ²é¿´ zf_device_ips114.h ÖÐ IPS114_SDA_PIN ºê¶¨Òå
   33           *                   RST                  ²é¿´ zf_device_ips114.h ÖÐ IPS114_RST_PIN ºê¶¨Òå
   34           *                   DC                   ²é¿´ zf_device_ips114.h ÖÐ IPS114_DC_PIN  ºê¶¨Òå
   35           *                   CS                   ²é¿´ zf_device_ips114.h ÖÐ IPS114_CS_PIN  ºê¶¨Òå
   36           *                   BLK                  ²é¿´ zf_device_ips114.h ÖÐ IPS114_BLK_PIN ºê¶¨Òå
   37           *                   VCC                 3.3VµçÔ´
   38           *                   GND                 µçÔ´µØ
   39           *                   ×î´ó·Ö±æÂÊ 135 * 240
   40           *                   ------------------------------------
   41           ********************************************************************************************************
             -************/
   42          
   43          #include "zf_common_clock.h"
   44          #include "zf_common_debug.h"
   45          #include "zf_common_font.h"
   46          #include "zf_common_function.h"
   47          #include "zf_driver_delay.h"
   48          #include "zf_driver_spi.h"
   49          
   50          #include "zf_device_ips114.h"
   51          
   52          #define IPS_LEN 240
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 2   

   53          #define IPS_WIGHT 135
   54          
   55          uint16 ips114_pencolor = IPS114_DEFAULT_PENCOLOR;
   56          uint16 ips114_bgcolor = IPS114_DEFAULT_BGCOLOR;
   57          
   58          ips114_dir_enum ips114_display_dir = IPS114_DEFAULT_DISPLAY_DIR;
   59          uint8 ips114_x_max = IPS_LEN;
   60          uint8 ips114_y_max = IPS_WIGHT;
   61          
   62          #if IPS114_USE_SOFT_SPI
               static soft_spi_info_struct ips114_spi;
               #define ips114_write_8bit_data(dat) soft_spi_write_8bit(&ips114_spi, dat)
               #define ips114_write_16bit_data(dat) soft_spi_write_16bit(&ips114_spi, dat)
               #else
   67          #define ips114_write_8bit_data(dat) spi_write_8bit(IPS114_SPI, dat)
   68          #define ips114_write_16bit_data(dat) spi_write_16bit(IPS114_SPI, dat)
   69          
   70          #endif
   71          
   72          //-------------------------------------------------------------------------------------------------------
             -------------
   73          // @brief       Ð´ÃüÁî ÄÚ²¿µ÷ÓÃ
   74          // @note        ÄÚ²¿µ÷ÓÃ ÓÃ»§ÎÞÐè¹ØÐÄ
   75          //-------------------------------------------------------------------------------------------------------
             -------------
   76          static void ips114_write_index(uint8 dat)
   77          {
   78   1          IPS114_CS(1);
   79   1          IPS114_CS(0);
   80   1          IPS114_DC(0);
   81   1          ips114_write_8bit_data(dat);
   82   1          IPS114_DC(1);
   83   1          IPS114_CS(1);
   84   1          IPS114_CS(0);
   85   1      }
   86          
   87          //-------------------------------------------------------------------------------------------------------
             -------------
   88          // @brief       ÉèÖÃÏÔÊ¾ÇøÓò ÄÚ²¿µ÷ÓÃ
   89          // @param       x1              ÆðÊ¼xÖá×ø±ê
   90          // @param       y1              ÆðÊ¼yÖá×ø±ê
   91          // @param       x2              ½áÊøxÖá×ø±ê
   92          // @param       y2              ½áÊøyÖá×ø±ê
   93          // @return      void
   94          // @note        ÄÚ²¿µ÷ÓÃ ÓÃ»§ÎÞÐè¹ØÐÄ
   95          //-------------------------------------------------------------------------------------------------------
             -------------
   96          static void ips114_set_region(uint16 x1, uint16 y1, uint16 x2, uint16 y2)
   97          {
   98   1          // zf_assert(x1 < ips114_x_max);
   99   1          // zf_assert(y1 < ips114_y_max);
  100   1          // zf_assert(x2 < ips114_x_max);
  101   1          // zf_assert(y2 < ips114_y_max);
  102   1      
  103   1          if (ips114_display_dir == IPS114_PORTAIT)
  104   1          {
  105   2              ips114_write_index(0x2a); // ÁÐµØÖ·ÉèÖÃ
  106   2              ips114_write_16bit_data(x1 + 52);
  107   2              ips114_write_16bit_data(x2 + 52);
  108   2              ips114_write_index(0x2b); // ÐÐµØÖ·ÉèÖÃ
  109   2              ips114_write_16bit_data(y1 + 40);
  110   2              ips114_write_16bit_data(y2 + 40);
  111   2              ips114_write_index(0x2c); // ´¢´æÆ÷Ð´
  112   2          }
  113   1          else if (ips114_display_dir == IPS114_PORTAIT_180)
  114   1          {
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 3   

  115   2              ips114_write_index(0x2a); // ÁÐµØÖ·ÉèÖÃ
  116   2              ips114_write_16bit_data(x1 + 53);
  117   2              ips114_write_16bit_data(x2 + 53);
  118   2              ips114_write_index(0x2b); // ÐÐµØÖ·ÉèÖÃ
  119   2              ips114_write_16bit_data(y1 + 40);
  120   2              ips114_write_16bit_data(y2 + 40);
  121   2              ips114_write_index(0x2c); // ´¢´æÆ÷Ð´
  122   2          }
  123   1          else if (ips114_display_dir == IPS114_CROSSWISE)
  124   1          {
  125   2              ips114_write_index(0x2a); // ÁÐµØÖ·ÉèÖÃ
  126   2              ips114_write_16bit_data(x1 + 40);
  127   2              ips114_write_16bit_data(x2 + 40);
  128   2              ips114_write_index(0x2b); // ÐÐµØÖ·ÉèÖÃ
  129   2              ips114_write_16bit_data(y1 + 53);
  130   2              ips114_write_16bit_data(y2 + 53);
  131   2              ips114_write_index(0x2c); // ´¢´æÆ÷Ð´
  132   2          }
  133   1          else
  134   1          {
  135   2              ips114_write_index(0x2a); // ÁÐµØÖ·ÉèÖÃ
  136   2              ips114_write_16bit_data(x1 + 40);
  137   2              ips114_write_16bit_data(x2 + 40);
  138   2              ips114_write_index(0x2b); // ÐÐµØÖ·ÉèÖÃ
  139   2              ips114_write_16bit_data(y1 + 52);
  140   2              ips114_write_16bit_data(y2 + 52);
  141   2              ips114_write_index(0x2c); // ´¢´æÆ÷Ð´
  142   2          }
  143   1      }
  144          
  145          //-------------------------------------------------------------------------------------------------------
             -------------
  146          // @brief       Òº¾§ÇåÆÁº¯Êý
  147          // @param       color           ÑÕÉ«¸ñÊ½ RGB565 »òÕß¿ÉÒÔÊ¹ÓÃ zf_common_font.h ÄÚ³£ÓÃÑÕÉ«ºê¶¨Òå
  148          // @return      void
  149          // Sample usage:                ips114_clear(YELLOW);
  150          //-------------------------------------------------------------------------------------------------------
             -------------
  151          void ips114_clear(uint16 color)
  152          {
  153   1          uint16 i, j;
  154   1          ips114_set_region(0, 0, ips114_x_max - 1, ips114_y_max - 1);
  155   1      
  156   1          for (i = 0; i < ips114_x_max; i++)
  157   1          {
  158   2              for (j = 0; j < ips114_y_max; j++)
  159   2              {
  160   3                  ips114_write_16bit_data(color);
  161   3              }
  162   2          }
  163   1      }
  164          
  165          //-------------------------------------------------------------------------------------------------------
             -------------
  166          // @brief       ÉèÖÃÏÔÊ¾·½Ïò Õâ¸öº¯ÊýÖ»ÓÐÔÚ³õÊ¼»¯ÆÁÄ»Ö®Ç°µ÷ÓÃ²ÅÉúÐ§
  167          // @param       dir             ÏÔÊ¾·½Ïò  ²ÎÕÕ zf_device_ips114.h ÄÚ ips114_dir_enum Ã¶¾ÙÌå¶¨Òå
  168          // @return      void
  169          // Sample usage:                ips114_set_dir(IPS114_CROSSWISE);
  170          //-------------------------------------------------------------------------------------------------------
             -------------
  171          void ips114_set_dir(ips114_dir_enum dir)
  172          {
  173   1          ips114_display_dir = dir;
  174   1          if (dir < 2)
  175   1          {
  176   2              ips114_x_max = IPS_WIGHT;
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 4   

  177   2              ips114_y_max = IPS_LEN;
  178   2          }
  179   1          else
  180   1          {
  181   2              ips114_x_max = IPS_LEN;
  182   2              ips114_y_max = IPS_WIGHT;
  183   2          }
  184   1      }
  185          
  186          //-------------------------------------------------------------------------------------------------------
             -------------
  187          // @brief       ÉèÖÃÏÔÊ¾ÑÕÉ«
  188          // @param       pen             ÑÕÉ«¸ñÊ½ RGB565 »òÕß¿ÉÒÔÊ¹ÓÃ zf_common_font.h ÄÚ³£ÓÃÑÕÉ«ºê¶¨Òå
  189          // @param       bgcolor         ÑÕÉ«¸ñÊ½ RGB565 »òÕß¿ÉÒÔÊ¹ÓÃ zf_common_font.h ÄÚ³£ÓÃÑÕÉ«ºê¶¨Òå
  190          // @return      void
  191          // Sample usage:                ips114_set_color(WHITE,BLACK);
  192          //-------------------------------------------------------------------------------------------------------
             -------------
  193          void ips114_set_color(uint16 pen, uint16 bgcolor)
  194          {
  195   1          ips114_pencolor = pen;
  196   1          ips114_bgcolor = bgcolor;
  197   1      }
  198          
  199          //-------------------------------------------------------------------------------------------------------
             -------------
  200          // @brief       Òº¾§»­µã
  201          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  202          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  203          // @param       dat             ÐèÒªÏÔÊ¾µÄÑÕÉ«
  204          // @return      void
  205          // Sample usage:                ips114_draw_point(0,0,RED);                     // ×ø±ê 0,0 »­Ò»¸öºìÉ«µÄµ
             -ã
  206          //-------------------------------------------------------------------------------------------------------
             -------------
  207          void ips114_draw_point(uint16 x, uint16 y, uint16 color)
  208          {
  209   1          // zf_assert(x < ips114_x_max);
  210   1          // zf_assert(y < ips114_y_max);
  211   1      
  212   1          ips114_set_region(x, y, x, y);
  213   1          ips114_write_16bit_data(color);
  214   1      }
  215          
  216          //-------------------------------------------------------------------------------------------------------
             -------------
  217          // @brief       Òº¾§ÏÔÊ¾×Ö·û
  218          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  219          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  220          // @param       dat             ÐèÒªÏÔÊ¾µÄ×Ö·û
  221          // @return      void
  222          // Sample usage:                ips114_show_char(0,0,'x');                      // ×ø±ê 0,0 Ð´Ò»¸ö×Ö·û x
  223          //-------------------------------------------------------------------------------------------------------
             -------------
  224          void ips114_show_char(uint16 x, uint16 y, const char dat)
  225          {
  226   1          // zf_assert(x < ips114_x_max);
  227   1          // zf_assert(y < ips114_y_max);
  228   1      
  229   1          uint8 i, j;
  230   1          uint8 temp;
  231   1      
  232   1          for (i = 0; i < 16; i++)
  233   1          {
  234   2              ips114_set_region(x, y + i, x + 7, y + i);
  235   2              temp = tft_ascii[dat - 32][i]; // ¼õ 32 ÒòÎªÊÇÈ¡Ä£ÊÇ´Ó¿Õ¸ñ¿ªÊ¼È¡µÃ ¿Õ¸ñÔÚ ascii ÖÐÐòºÅÊÇ 32
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 5   

  236   2              for (j = 0; j < 8; j++)
  237   2              {
  238   3                  if (temp & 0x01)
  239   3                      ips114_write_16bit_data(ips114_pencolor);
  240   3                  else
  241   3                      ips114_write_16bit_data(ips114_bgcolor);
  242   3                  temp >>= 1;
  243   3              }
  244   2          }
  245   1      }
  246          
  247          //-------------------------------------------------------------------------------------------------------
             -------------
  248          // @brief       Òº¾§ÏÔÊ¾×Ö·û´®
  249          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  250          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  251          // @param       dat             ÐèÒªÏÔÊ¾µÄ×Ö·û´®
  252          // @return      void
  253          // Sample usage:                ips114_show_string(0,0,"seekfree");
  254          //-------------------------------------------------------------------------------------------------------
             -------------
  255          void ips114_show_string(uint16 x, uint16 y, const char dat[])
  256          {
  257   1          // zf_assert(x < ips114_x_max);
  258   1          // zf_assert(y < ips114_y_max);
  259   1      
  260   1          uint16 j = 0;
  261   1          while (dat[j] != '\0')
  262   1          {
  263   2              ips114_show_char(x + 8 * j, y, dat[j]);
  264   2              j++;
  265   2          }
  266   1      }
  267          
  268          //-------------------------------------------------------------------------------------------------------
             -------------
  269          //  @brief      Òº¾§ÏÔÊ¾8Î»ÓÐ·ûºÅ
  270          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  271          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  272          //  @param      dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿£¬Êý¾ÝÀàÐÍint8
  273          //  @return     void
  274          //  Sample usage:               ips114_show_int8(0,0,x);                        // xÎª int8 ÀàÐÍ
  275          //-------------------------------------------------------------------------------------------------------
             -------------
  276          void ips114_show_int8(uint16 x, uint16 y, int8 dat)
  277          {
  278   1          // zf_assert(x < ips114_x_max);
  279   1          // zf_assert(y < ips114_y_max);
  280   1      
  281   1          uint8 a[3];
  282   1          uint8 i;
  283   1          if (dat < 0)
  284   1          {
  285   2              ips114_show_char(x, y, '-');
  286   2              dat = -dat;
  287   2          }
  288   1          else
  289   1              ips114_show_char(x, y, ' ');
  290   1      
  291   1          a[0] = dat / 100;
  292   1          a[1] = dat / 10 % 10;
  293   1          a[2] = dat % 10;
  294   1          i = 0;
  295   1          while (i < 3)
  296   1          {
  297   2              ips114_show_char(x + (8 * (i + 1)), y, (uint8)('0' + a[i]));
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 6   

  298   2              i++;
  299   2          }
  300   1      }
  301          
  302          //-------------------------------------------------------------------------------------------------------
             -------------
  303          // @brief       Òº¾§ÏÔÊ¾8Î»ÎÞ·ûºÅ
  304          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  305          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  306          // @param       dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿ Êý¾ÝÀàÐÍuint8
  307          // @return      void
  308          // Sample usage:                ips114_show_uint8(0,0,x);                       // x Îª uint8 ÀàÐÍ
  309          //-------------------------------------------------------------------------------------------------------
             -------------
  310          void ips114_show_uint8(uint16 x, uint16 y, uint8 dat)
  311          {
  312   1          // zf_assert(x < ips114_x_max);
  313   1          // zf_assert(y < ips114_y_max);
  314   1      
  315   1          uint8 a[3];
  316   1          uint8 i;
  317   1      
  318   1          a[0] = dat / 100;
  319   1          a[1] = dat / 10 % 10;
  320   1          a[2] = dat % 10;
  321   1          i = 0;
  322   1          while (i < 3)
  323   1          {
  324   2              ips114_show_char(x + (8 * i), y, (uint8)('0' + a[i]));
  325   2              i++;
  326   2          }
  327   1      }
  328          
  329          //-------------------------------------------------------------------------------------------------------
             -------------
  330          // @brief       Òº¾§ÏÔÊ¾16Î»ÓÐ·ûºÅ
  331          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  332          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  333          // @param       dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿ Êý¾ÝÀàÐÍint16
  334          // @return      void
  335          // Sample usage:                ips114_show_int16(0,0,x);                       // x Îª int16 ÀàÐÍ
  336          //-------------------------------------------------------------------------------------------------------
             -------------
  337          void ips114_show_int16(uint16 x, uint16 y, int16 dat)
  338          {
  339   1          // zf_assert(x < ips114_x_max);
  340   1          // zf_assert(y < ips114_y_max);
  341   1      
  342   1          uint8 a[5];
  343   1          uint8 i;
  344   1      
  345   1          if (dat < 0)
  346   1          {
  347   2              ips114_show_char(x, y, '-');
  348   2              dat = -dat;
  349   2          }
  350   1          else
  351   1              ips114_show_char(x, y, ' ');
  352   1      
  353   1          a[0] = dat / 10000;
  354   1          a[1] = dat / 1000 % 10;
  355   1          a[2] = dat / 100 % 10;
  356   1          a[3] = dat / 10 % 10;
  357   1          a[4] = dat % 10;
  358   1      
  359   1          i = 0;
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 7   

  360   1          while (i < 5)
  361   1          {
  362   2              ips114_show_char(x + (8 * (i + 1)), y, (uint8)('0' + a[i]));
  363   2              i++;
  364   2          }
  365   1      }
  366          
  367          //-------------------------------------------------------------------------------------------------------
             -------------
  368          // @brief       Òº¾§ÏÔÊ¾16Î»ÎÞ·ûºÅ
  369          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  370          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  371          // @param       dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿£¬Êý¾ÝÀàÐÍuint16
  372          // @return      void
  373          // Sample usage:                ips114_show_uint16(0,0,x);                      // x Îª uint16 ÀàÐÍ
  374          //-------------------------------------------------------------------------------------------------------
             -------------
  375          void ips114_show_uint16(uint16 x, uint16 y, uint16 dat)
  376          {
  377   1          // zf_assert(x < ips114_x_max);
  378   1          // zf_assert(y < ips114_y_max);
  379   1      
  380   1          uint8 a[5];
  381   1          uint8 i;
  382   1      
  383   1          a[0] = dat / 10000;
  384   1          a[1] = dat / 1000 % 10;
  385   1          a[2] = dat / 100 % 10;
  386   1          a[3] = dat / 10 % 10;
  387   1          a[4] = dat % 10;
  388   1      
  389   1          i = 0;
  390   1          while (i < 5)
  391   1          {
  392   2              ips114_show_char(x + (8 * i), y, (uint8)('0' + a[i]));
  393   2              i++;
  394   2          }
  395   1      }
  396          
  397          //-------------------------------------------------------------------------------------------------------
             -------------
  398          // @brief       Òº¾§ÏÔÊ¾32Î»ÓÐ·ûºÅ(È¥³ýÕûÊý²¿·ÖÎÞÐ§µÄ0)
  399          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  400          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  401          // @param       dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿£¬Êý¾ÝÀàÐÍuint32
  402          // @param       num             ÐèÒªÏÔÊ¾µÄÎ»Êý ×î¸ß10Î»  ²»°üº¬Õý¸ººÅ
  403          // @return      void
  404          // Sample usage:                ips114_show_int32(0,0,x,3);                     // x ¿ÉÒÔÎª int32 uint16 
             -int16 uint8 int8 ÀàÐÍ
  405          // note:                        ¸ºÊý»áÏÔÊ¾Ò»¸ö ¡®-¡¯ºÅ   ÕýÊýÏÔÊ¾Ò»¸ö¿Õ¸ñ
  406          //-------------------------------------------------------------------------------------------------------
             -------------
  407          void ips114_show_int32(uint16 x, uint16 y, int32 dat, uint8 num)
  408          {
  409   1          // zf_assert(x < ips114_x_max);
  410   1          // zf_assert(y < ips114_y_max);
  411   1      
  412   1          int8 buff[34];
  413   1          uint8 length;
  414   1      
  415   1          if (10 < num)
  416   1              num = 10;
  417   1      
  418   1          num++;
  419   1          if (0 > dat)
  420   1              length = zf_sprintf(&buff[0], (const int8 *)"%d", dat); // ¸ºÊý
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 8   

  421   1          else
  422   1          {
  423   2              buff[0] = ' ';
  424   2              length = zf_sprintf(&buff[1], (const int8 *)"%d", dat);
  425   2              length++;
  426   2          }
  427   1          while (length < num)
  428   1          {
  429   2              buff[length] = ' ';
  430   2              length++;
  431   2          }
  432   1          buff[num] = '\0';
  433   1      
  434   1          ips114_show_string(x, y, (const char *)buff); // ÏÔÊ¾Êý×Ö
  435   1      }
  436          
  437          //-------------------------------------------------------------------------------------------------------
             -------------
  438          // @brief       Òº¾§ÏÔÊ¾¸¡µãÊý(È¥³ýÕûÊý²¿·ÖÎÞÐ§µÄ0)
  439          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  440          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  441          // @param       dat             ÐèÒªÏÔÊ¾µÄ±äÁ¿£¬Êý¾ÝÀàÐÍfloat»òdouble
  442          // @param       num             ÕûÊýÎ»ÏÔÊ¾³¤¶È   ×î¸ß10Î»
  443          // @param       pointnum        Ð¡ÊýÎ»ÏÔÊ¾³¤¶È   ×î¸ß6Î»
  444          // @return      void
  445          // Sample usage:                ips114_show_float(0,0,x,2,3);                    // ÏÔÊ¾¸¡µãÊý   ÕûÊýÏÔÊ¾
             -2Î»   Ð¡ÊýÏÔÊ¾ÈýÎ»
  446          // @note                        ÌØ±ð×¢Òâµ±·¢ÏÖÐ¡Êý²¿·ÖÏÔÊ¾µÄÖµÓëÄãÐ´ÈëµÄÖµ²»Ò»ÑùµÄÊ±ºò£¬
  447          //                              ¿ÉÄÜÊÇÓÉÓÚ¸¡µãÊý¾«¶È¶ªÊ§ÎÊÌâµ¼ÖÂµÄ£¬Õâ²¢²»ÊÇÏÔÊ¾º¯ÊýµÄÎÊÌâ£¬
  448          //                              ÓÐ¹ØÎÊÌâµÄÏêÇé£¬Çë×ÔÐÐ°Ù¶ÈÑ§Ï°   ¸¡µãÊý¾«¶È¶ªÊ§ÎÊÌâ¡£
  449          //                              ¸ºÊý»áÏÔÊ¾Ò»¸ö ¡®-¡¯ºÅ   ÕýÊýÏÔÊ¾Ò»¸ö¿Õ¸ñ
  450          //-------------------------------------------------------------------------------------------------------
             -------------
  451          void ips114_show_float(uint16 x, uint16 y, double dat, uint8 num, uint8 pointnum)
  452          {
  453   1          // zf_assert(x < ips114_x_max);
  454   1          // zf_assert(y < ips114_y_max);
  455   1      
  456   1          uint8 length;
  457   1          int8 buff[34];
  458   1          int8 start, end, point;
  459   1      
  460   1          if (6 < pointnum)
  461   1              pointnum = 6;
  462   1          if (10 < num)
  463   1              num = 10;
  464   1      
  465   1          if (0 > dat)
  466   1              length = zf_sprintf(&buff[0], (const int8 *)"%f", dat); // ¸ºÊý
  467   1          else
  468   1          {
  469   2              length = zf_sprintf(&buff[1], (const int8 *)"%f", dat);
  470   2              length++;
  471   2          }
  472   1          point = length - 7;         // ¼ÆËãÐ¡ÊýµãÎ»ÖÃ
  473   1          start = point - num - 1;    // ¼ÆËãÆðÊ¼Î»
  474   1          end = point + pointnum + 1; // ¼ÆËã½áÊøÎ»
  475   1          while (0 > start)           // ÕûÊýÎ»²»¹»  Ä©Î²Ó¦¸ÃÌî³ä¿Õ¸ñ
  476   1          {
  477   2              buff[end] = ' ';
  478   2              end++;
  479   2              start++;
  480   2          }
  481   1      
  482   1          if (0 > dat)
  483   1              buff[start] = '-';
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 9   

  484   1          else
  485   1              buff[start] = ' ';
  486   1      
  487   1          buff[end] = '\0';
  488   1      
  489   1          ips114_show_string(x, y, (const char *)buff); // ÏÔÊ¾Êý×Ö
  490   1      }
  491          
  492          //-------------------------------------------------------------------------------------------------------
             -------------
  493          // @brief       IPS114 ÏÔÊ¾²¨ÐÎ
  494          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  495          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  496          // @param       *p              ²¨ÐÎÊý×éÖ¸Õë
  497          // @param       width           ²¨ÐÎÊµ¼Ê¿í¶È
  498          // @param       value_max       ²¨ÐÎÊµ¼Ê×î´óÖµ
  499          // @param       dis_width       ²¨ÐÎÏÔÊ¾¿í¶È ²ÎÊý·¶Î§ [0, ips114_x_max]
  500          // @param       dis_value_max   ²¨ÐÎÏÔÊ¾×î´óÖµ ²ÎÊý·¶Î§ [0, ips114_y_max]
  501          // @return      void
  502          // Sample usage:                ips114_show_gray_image(0,0,camera_buffer_addr,MT9V03X_W,MT9V03X_H,240,135
             -,128);
  503          //-------------------------------------------------------------------------------------------------------
             -------------
  504          void ips114_show_wave(uint16 x, uint16 y, uint8 *p, uint16 width, uint16 value_max, uint16 dis_width, uin
             -t16 dis_value_max)
  505          {
  506   1          // zf_assert(x < ips114_x_max);
  507   1          // zf_assert(y < ips114_y_max);
  508   1      
  509   1          uint32 i = 0, j = 0;
  510   1          uint32 width_index, value_max_index;
  511   1      
  512   1          ips114_set_region(x, y, x + dis_width - 1, y + dis_value_max - 1); // ÉèÖÃÏÔÊ¾ÇøÓò
  513   1          for (i = 0; i < dis_value_max; i++)
  514   1          {
  515   2              for (j = 0; j < dis_width; j++)
  516   2              {
  517   3                  ips114_write_16bit_data(ips114_bgcolor);
  518   3              }
  519   2          }
  520   1      
  521   1          for (i = 0; i < dis_width; i++)
  522   1          {
  523   2              width_index = i * width / dis_width;
  524   2              value_max_index = *(p + width_index) * (dis_value_max - 1) / value_max;
  525   2              ips114_draw_point(i + x, (dis_value_max - 1) - value_max_index + y, ips114_pencolor);
  526   2          }
  527   1      }
  528          
  529          //-------------------------------------------------------------------------------------------------------
             -------------
  530          // @brief       ºº×ÖÏÔÊ¾
  531          // @param       x               ×ø±êx·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_x_max-1]
  532          // @param       y               ×ø±êy·½ÏòµÄÆðµã ²ÎÊý·¶Î§ [0, ips114_y_max-1]
  533          // @param       siz            È¡Ä£µÄÊ±ºòÉèÖÃµÄºº×Ö×ÖÌå´óÐ¡ Ò²¾ÍÊÇÒ»¸öºº×ÖÕ¼ÓÃµÄµãÕó³¤¿íÎª¶àÉÙ¸öµã È¡Ä£µÄ
             -Ê±ºòÐèÒª³¤¿íÊÇÒ»ÑùµÄ
  534          // @param       *p              ÐèÒªÏÔÊ¾µÄºº×ÖÊý×é
  535          // @param       number          ÐèÒªÏÔÊ¾¶àÉÙÎ»
  536          // @param       color           ÏÔÊ¾ÑÕÉ«
  537          // @return      void
  538          // Sample usage:                ips114_show_chinese(0,0,16,chinese_test[0],4,RED);//ÏÔÊ¾fontÎÄ¼þÀïÃæµÄ Ê¾
             -Àý
  539          // @Note                        Ê¹ÓÃPCtoLCD2002Èí¼þÈ¡Ä£           ÒõÂë¡¢ÖðÐÐÊ½¡¢Ë³Ïò   16*16
  540          //-------------------------------------------------------------------------------------------------------
             -------------
  541          void ips114_show_chinese(uint16 x, uint16 y, uint8 siz, const uint8 *p, uint8 number, uint16 color)
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 10  

  542          {
  543   1          // zf_assert(x < ips114_x_max);
  544   1          // zf_assert(y < ips114_y_max);
  545   1      
  546   1          int i, j, k;
  547   1          uint8 temp, temp1, temp2;
  548   1          const uint8 *p_data;
  549   1      
  550   1          temp2 = siz / 8;
  551   1      
  552   1          ips114_set_region(x, y, number * siz - 1 + x, y + siz - 1);
  553   1      
  554   1          for (i = 0; i < siz; i++)
  555   1          {
  556   2              temp1 = number;
  557   2              p_data = p + i * temp2;
  558   2              while (temp1--)
  559   2              {
  560   3                  for (k = 0; k < temp2; k++)
  561   3                  {
  562   4                      for (j = 8; j > 0; j--)
  563   4                      {
  564   5                          temp = (*p_data >> (j - 1)) & 0x01;
  565   5                          if (temp)
  566   5                              ips114_write_16bit_data(color);
  567   5                          else
  568   5                              ips114_write_16bit_data(ips114_bgcolor);
  569   5                      }
  570   4                      p_data++;
  571   4                  }
  572   3                  p_data = p_data - temp2 + temp2 * siz;
  573   3              }
  574   2          }
  575   1      }
  576          
  577          //-------------------------------------------------------------------------------------------------------
             -------------
  578          // @brief       1.14´ç IPSÒº¾§³õÊ¼»¯
  579          // @return      void
  580          // Sample usage:                ips114_init();
  581          //-------------------------------------------------------------------------------------------------------
             -------------
  582          void ips114_init(void)
  583          {
  584   1      #if IPS114_USE_SOFT_SPI
                   soft_spi_init(&ips114_spi, 0, IPS114_SOFT_SPI_DELAY, IPS114_SCL_PIN, IPS114_SDA_PIN, SOFT_SPI_PIN_NUL
             -L, SOFT_SPI_PIN_NULL);
               #else
  587   1          // zf_assert(IPS114_SPI != (IPS114_SCL_PIN&0xF000>>12));
  588   1          // zf_assert(IPS114_SPI != (IPS114_SDA_PIN&0xF000>>12));
  589   1          spi_init(IPS114_SPI, SPI_MODE0, IPS114_SPI_SPEED, IPS114_SCL_PIN, IPS114_SDA_PIN, SPI_MISO_NULL, SPI_
             -CS_NULL);
  590   1      #endif
  591   1      
  592   1          //    gpio_init(IPS114_DC_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  593   1          //    gpio_init(IPS114_RST_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  594   1          //    gpio_init(IPS114_CS_PIN, GPO, GPIO_LOW, GPO_PUSH_PULL);
  595   1          //    gpio_init(IPS114_BLK_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
  596   1      
  597   1          ips114_set_dir(ips114_display_dir);
  598   1          ips114_set_color(ips114_pencolor, ips114_bgcolor);
  599   1      
  600   1          IPS114_RST(0);
  601   1          system_delay_ms(200);
  602   1      
  603   1          IPS114_RST(1);
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 11  

  604   1          system_delay_ms(100);
  605   1      
  606   1          ips114_write_index(0x36);
  607   1          system_delay_ms(100);
  608   1          if (ips114_display_dir == 0)
  609   1              ips114_write_8bit_data(0x00);
  610   1          else if (ips114_display_dir == 1)
  611   1              ips114_write_8bit_data(0xC0);
  612   1          else if (ips114_display_dir == 2)
  613   1              ips114_write_8bit_data(0x70);
  614   1          else
  615   1              ips114_write_8bit_data(0xA0);
  616   1      
  617   1          ips114_write_index(0x3A);
  618   1          ips114_write_8bit_data(0x05);
  619   1      
  620   1          ips114_write_index(0xB2);
  621   1          ips114_write_8bit_data(0x0C);
  622   1          ips114_write_8bit_data(0x0C);
  623   1          ips114_write_8bit_data(0x00);
  624   1          ips114_write_8bit_data(0x33);
  625   1          ips114_write_8bit_data(0x33);
  626   1      
  627   1          ips114_write_index(0xB7);
  628   1          ips114_write_8bit_data(0x35);
  629   1      
  630   1          ips114_write_index(0xBB);
  631   1          ips114_write_8bit_data(0x37);
  632   1      
  633   1          ips114_write_index(0xC0);
  634   1          ips114_write_8bit_data(0x2C);
  635   1      
  636   1          ips114_write_index(0xC2);
  637   1          ips114_write_8bit_data(0x01);
  638   1      
  639   1          ips114_write_index(0xC3);
  640   1          ips114_write_8bit_data(0x12);
  641   1      
  642   1          ips114_write_index(0xC4);
  643   1          ips114_write_8bit_data(0x20);
  644   1      
  645   1          ips114_write_index(0xC6);
  646   1          ips114_write_8bit_data(0x0F);
  647   1      
  648   1          ips114_write_index(0xD0);
  649   1          ips114_write_8bit_data(0xA4);
  650   1          ips114_write_8bit_data(0xA1);
  651   1      
  652   1          ips114_write_index(0xE0);
  653   1          ips114_write_8bit_data(0xD0);
  654   1          ips114_write_8bit_data(0x04);
  655   1          ips114_write_8bit_data(0x0D);
  656   1          ips114_write_8bit_data(0x11);
  657   1          ips114_write_8bit_data(0x13);
  658   1          ips114_write_8bit_data(0x2B);
  659   1          ips114_write_8bit_data(0x3F);
  660   1          ips114_write_8bit_data(0x54);
  661   1          ips114_write_8bit_data(0x4C);
  662   1          ips114_write_8bit_data(0x18);
  663   1          ips114_write_8bit_data(0x0D);
  664   1          ips114_write_8bit_data(0x0B);
  665   1          ips114_write_8bit_data(0x1F);
  666   1          ips114_write_8bit_data(0x23);
  667   1      
  668   1          ips114_write_index(0xE1);
  669   1          ips114_write_8bit_data(0xD0);
C251 COMPILER V5.60.0,  zf_device_ips114                                                   23/11/25  21:51:04  PAGE 12  

  670   1          ips114_write_8bit_data(0x04);
  671   1          ips114_write_8bit_data(0x0C);
  672   1          ips114_write_8bit_data(0x11);
  673   1          ips114_write_8bit_data(0x13);
  674   1          ips114_write_8bit_data(0x2C);
  675   1          ips114_write_8bit_data(0x3F);
  676   1          ips114_write_8bit_data(0x44);
  677   1          ips114_write_8bit_data(0x51);
  678   1          ips114_write_8bit_data(0x2F);
  679   1          ips114_write_8bit_data(0x1F);
  680   1          ips114_write_8bit_data(0x1F);
  681   1          ips114_write_8bit_data(0x20);
  682   1          ips114_write_8bit_data(0x23);
  683   1      
  684   1          ips114_write_index(0x21);
  685   1      
  686   1          ips114_write_index(0x11);
  687   1          system_delay_ms(120);
  688   1      
  689   1          ips114_write_index(0x29);
  690   1      
  691   1          ips114_clear(ips114_bgcolor);
  692   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4161     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       248     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        39     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
