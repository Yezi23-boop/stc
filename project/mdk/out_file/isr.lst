C251 COMPILER V5.60.0,  isr                                                                22/11/25  23:09:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\out_file\isr.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\isr.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BR
                    -OWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;
                    -..\user;..\code) DEBUG PRINT(.\out_file\isr.lst) OBJECT(.\out_file\isr.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * AI8051U Opensourec Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3           * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4           *
    5           * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6           *
    7           * AI8051U ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8           * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9           * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10           *
   11           * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12           * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13           * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14           *
   15           * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16           * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17           *
   18           * ¶îÍâ×¢Ã÷£º
   19           * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20           * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21           * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22           * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23           *
   24           * ÎÄ¼þÃû³Æ
   25           * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26           * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27           * ¿ª·¢»·¾³          MDK FOR C251
   28           * ÊÊÓÃÆ½Ì¨          AI8051U
   29           * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30           *
   31           * ÐÞ¸Ä¼ÇÂ¼
   32           * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33           * 2024-08-01        ´óW            first version
   34           ********************************************************************************************************
             -************/
   35          
   36          #include "zf_common_headfile.h"
   37          void DMA_UART1_IRQHandler(void) interrupt 4
   38          {
   39   1          static vuint8 dwon_count = 0;
   40   1          if (DMA_UR1R_STA & 0x01) // ½ÓÊÕÍê³É
   41   1          {
   42   2              DMA_UR1R_STA &= ~0x01;      // Çå±êÖ¾Î»
   43   2              uart_rx_start_buff(UART_1); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
   44   2      
   45   2              // ³ÌÐò×Ô¶¯ÏÂÔØ
   46   2              if (uart_rx_buff[UART_1][0] == 0x7F)
   47   2              {
   48   3                  if (dwon_count++ > 20)
   49   3                  {
   50   4                      IAP_CONTR = 0x60;
   51   4                  }
   52   3              }
   53   2              else
   54   2              {
   55   3                  dwon_count = 0;
C251 COMPILER V5.60.0,  isr                                                                22/11/25  23:09:29  PAGE 2   

   56   3              }
   57   2      
   58   2              if (uart1_irq_handler != NULL)
   59   2              {
   60   3                  uart1_irq_handler(uart_rx_buff[UART_1][0]);
   61   3              }
   62   2          }
   63   1      
   64   1          if (DMA_UR1R_STA & 0x02) // Êý¾Ý¶ªÆú
   65   1          {
   66   2              DMA_UR1R_STA &= ~0x02;      // Çå±êÖ¾Î»
   67   2              uart_rx_start_buff(UART_1); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
   68   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   69   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   70   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   71   2          }
   72   1      }
   73          
   74          void DMA_UART2_IRQHandler(void) interrupt 8
   75          {
   76   1      
   77   1          if (DMA_UR2R_STA & 0x01) // ½ÓÊÕÍê³É
   78   1          {
   79   2              DMA_UR2R_STA &= ~0x01;      // Çå±êÖ¾Î»
   80   2              uart_rx_start_buff(UART_2); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
   81   2      
   82   2              if (uart2_irq_handler != NULL)
   83   2              {
   84   3                  uart2_irq_handler(uart_rx_buff[UART_2][0]);
   85   3              }
   86   2          }
   87   1      
   88   1          if (DMA_UR2R_STA & 0x02) // Êý¾Ý¶ªÆú
   89   1          {
   90   2              DMA_UR2R_STA &= ~0x02;      // Çå±êÖ¾Î»
   91   2              uart_rx_start_buff(UART_2); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
   92   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   93   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   94   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
   95   2          }
   96   1      }
   97          
   98          void DMA_UART3_IRQHandler(void) interrupt 17
   99          {
  100   1      
  101   1          if (DMA_UR3R_STA & 0x01) // ½ÓÊÕÍê³É
  102   1          {
  103   2              DMA_UR3R_STA &= ~0x01;      // Çå±êÖ¾Î»
  104   2              uart_rx_start_buff(UART_3); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
  105   2      
  106   2              if (uart3_irq_handler != NULL)
  107   2              {
  108   3      
  109   3                  uart3_irq_handler(uart_rx_buff[UART_3][0]);
  110   3              }
  111   2          }
  112   1      
  113   1          if (DMA_UR3R_STA & 0x02) // Êý¾Ý¶ªÆú
  114   1          {
  115   2              DMA_UR3R_STA &= ~0x02;      // Çå±êÖ¾Î»
  116   2              uart_rx_start_buff(UART_3); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
  117   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  118   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  119   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  120   2          }
  121   1      }
C251 COMPILER V5.60.0,  isr                                                                22/11/25  23:09:29  PAGE 3   

  122          
  123          void DMA_UART4_IRQHandler(void) interrupt 18
  124          {
  125   1      
  126   1          if (DMA_UR4R_STA & 0x01) // ½ÓÊÕÍê³É
  127   1          {
  128   2              DMA_UR4R_STA &= ~0x01;      // Çå±êÖ¾Î»
  129   2              uart_rx_start_buff(UART_4); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
  130   2      
  131   2              if (uart4_irq_handler != NULL)
  132   2              {
  133   3                  uart4_irq_handler(uart_rx_buff[UART_4][0]);
  134   3              }
  135   2          }
  136   1      
  137   1          if (DMA_UR4R_STA & 0x02) // Êý¾Ý¶ªÆú
  138   1          {
  139   2              DMA_UR4R_STA &= ~0x02;      // Çå±êÖ¾Î»
  140   2              uart_rx_start_buff(UART_4); // ÉèÖÃÏÂÒ»´Î½ÓÊÕ£¬Îñ±Ø±£Áô
  141   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  142   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  143   2              // Èç¹û½øÈëÁËÕâ¸öÖÐ¶Ï£¬Ôò´ú±íUARTµÄÊý¾ÝÔÚÃ»ÓÐÈ¡×ßÖ®Ç°±»¸²¸Ç!
  144   2          }
  145   1      }
  146          
  147          uint32 time_0 = 0; // Ê±¼ä¼ÆÊýÆ÷
  148          static int test_time = 0;
  149          int flat_statr = 0;
  150          static int flat_statr_date = 0;
  151          void TM0_IRQHandler() interrupt 1
  152          {
  153   1          TIM0_CLEAR_FLAG;
  154   1          if (!P32)
  155   1              IAP_CONTR = 0x60;   // ÅÐ¶Ï¿ìËÙÉÕÂ¼
  156   1          scan_track_max_value(); // »ñÈ¡µç¸Ð×î´óÖµ
  157   1          read_AD();              // ¶ÁÈ¡²¢´¦Àíµç¸ÐÊý¾Ý
  158   1          Encoder_get(&PID.left_speed, &PID.right_speed);
  159   1          Prepare_Data();
  160   1          lost_lines();
  161   1          // ½á¹¹Ìå³ÉÔ±ÎªÖ÷£ºµ÷ÓÃºó´Ó pid->output ¶ÁÈ¡½á¹û
  162   1          pid_steer_update(&PID.steer, Err, -imu660ra_gyro_z * 0.01);                              // ¸üÐÂ×ªÏò£
             -¨Î»ÖÃÊ½£©PID_Direction
  163   1          pid_speed_update(&PID.left_speed, speed_run - PID.steer.output, PID.left_speed.speed);   // ¸üÐÂ×óÂÖË
             -Ù¶È»·
  164   1          pid_speed_update(&PID.right_speed, speed_run + PID.steer.output, PID.right_speed.speed); // ¸üÐÂÓÒÂÖË
             -Ù¶È»·
  165   1          if (flat_statr >= 2 && lost_spto == 0)
  166   1          {
  167   2              motor_output((int)PID.left_speed.output, (int)PID.right_speed.output);
  168   2          }
  169   1          //    test();
  170   1          if (tim0_irq_handler != NULL)
  171   1          {
  172   2              tim0_irq_handler();
  173   2          }
  174   1      }
  175          void TM1_IRQHandler() interrupt 3
  176          {
  177   1          TIM1_CLEAR_FLAG;
  178   1          IMUupdate(&Gyr_filt, &Acc_filt, &Att_Angle);
  179   1          dianya_adc();
  180   1          flat_statr_date++;
  181   1          if (P35 == 0 && flat_statr_date > 50)
  182   1          {
  183   2              flat_statr++;
  184   2              flat_statr_date = 0;
C251 COMPILER V5.60.0,  isr                                                                22/11/25  23:09:29  PAGE 4   

  185   2          }
  186   1          if (flat_statr >= 1 && lost_spto == 0 && start_flag == 1)
  187   1          {
  188   2              fuya_update_simple();
  189   2          }
  190   1          if (tim1_irq_handler != NULL)
  191   1          {
  192   2              tim1_irq_handler();
  193   2          }
  194   1      }
  195          void TM2_IRQHandler() interrupt 12
  196          {
  197   1          TIM2_CLEAR_FLAG;
  198   1      
  199   1          if (tim2_irq_handler != NULL)
  200   1          {
  201   2              tim2_irq_handler();
  202   2          }
  203   1      }
  204          void TM3_IRQHandler() interrupt 19
  205          {
  206   1          TIM3_CLEAR_FLAG;
  207   1      
  208   1          if (tim3_irq_handler != NULL)
  209   1          {
  210   2              tim3_irq_handler();
  211   2          }
  212   1      }
  213          
  214          void TM4_IRQHandler() interrupt 20
  215          {
  216   1          TIM4_CLEAR_FLAG;
  217   1      
  218   1          if (tim4_irq_handler != NULL)
  219   1          {
  220   2              tim4_irq_handler();
  221   2          }
  222   1      }
  223          
  224          void TM11_IRQHandler() interrupt 24
  225          {
  226   1          TIM11_CLEAR_FLAG;
  227   1      
  228   1          if (tim11_irq_handler != NULL)
  229   1          {
  230   2              tim11_irq_handler();
  231   2          }
  232   1      }
  233          
  234          // #define     INT0_VECTOR             0       //0003H
  235          // #define     TMR0_VECTOR             1       //000BH
  236          // #define     INT1_VECTOR             2       //0013H
  237          // #define     TMR1_VECTOR             3       //001BH
  238          // #define     UART1_VECTOR            4       //0023H
  239          // #define     ADC_VECTOR              5       //002BH
  240          // #define     LVD_VECTOR              6       //0033H
  241          // #define     PCA_VECTOR              7       //003BH
  242          // #define     UART2_VECTOR            8       //0043H
  243          // #define     SPI_VECTOR              9       //004BH
  244          // #define     INT2_VECTOR             10      //0053H
  245          // #define     INT3_VECTOR             11      //005BH
  246          // #define     TMR2_VECTOR             12      //0063H
  247          // #define     USER_VECTOR             13      //006BH
  248          // #define     INT4_VECTOR             16      //0083H
  249          // #define     UART3_VECTOR            17      //008BH
  250          // #define     UART4_VECTOR            18      //0093H
C251 COMPILER V5.60.0,  isr                                                                22/11/25  23:09:29  PAGE 5   

  251          // #define     TMR3_VECTOR             19      //009BH
  252          // #define     TMR4_VECTOR             20      //00A3H
  253          // #define     CMP_VECTOR              21      //00ABH
  254          // #define     I2C_VECTOR              24      //00C3H
  255          // #define     USB_VECTOR              25      //00CBH
  256          // #define     PWMA_VECTOR             26      //00D3H
  257          // #define     PWMB_VECTOR             27      //00DBH
  258          
  259          // #define     RTC_VECTOR              36      //0123H
  260          // #define     P0INT_VECTOR            37      //012BH
  261          // #define     P1INT_VECTOR            38      //0133H
  262          // #define     P2INT_VECTOR            39      //013BH
  263          // #define     P3INT_VECTOR            40      //0143H
  264          // #define     P4INT_VECTOR            41      //014BH
  265          // #define     P5INT_VECTOR            42      //0153H
  266          // #define     P6INT_VECTOR            43      //015BH
  267          // #define     P7INT_VECTOR            44      //0163H
  268          // #define     DMA_M2M_VECTOR          47      //017BH
  269          // #define     DMA_ADC_VECTOR          48      //0183H
  270          // #define     DMA_SPI_VECTOR          49      //018BH
  271          // #define     DMA_UR1T_VECTOR         50      //0193H
  272          // #define     DMA_UR1R_VECTOR         51      //019BH
  273          // #define     DMA_UR2T_VECTOR         52      //01A3H
  274          // #define     DMA_UR2R_VECTOR         53      //01ABH
  275          // #define     DMA_UR3T_VECTOR         54      //01B3H
  276          // #define     DMA_UR3R_VECTOR         55      //01BBH
  277          // #define     DMA_UR4T_VECTOR         56      //01C3H
  278          // #define     DMA_UR4R_VECTOR         57      //01CBH
  279          // #define     DMA_LCM_VECTOR          58      //01D3H
  280          // #define     LCM_VECTOR              59      //01DBH
  281          // #define     DMA_I2CT_VECTOR         60      //01E3H
  282          // #define     DMA_I2CR_VECTOR         61      //01EBH
  283          // #define     I2S_VECTOR              62      //01F3H
  284          // #define     DMA_I2ST_VECTOR         63      //01FBH
  285          // #define     DMA_I2SR_VECTOR         64      //0203H
  286          // #define     DMA_QSPI_VECTOR         65      //020BH
  287          // #define     QSPI_VECTOR             66      //0213H
  288          // #define     TMR11_VECTOR            67      //021BH
  289          // #define     DMA_PWMAT_VECTOR        72      //0243H
  290          // #define     DMA_PWMAR_VECTOR        73      //024BH


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1463     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        11     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        36     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
