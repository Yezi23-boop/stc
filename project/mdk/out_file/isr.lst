C251 COMPILER V5.60.0,  isr                                                                21/11/25  22:30:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\out_file\isr.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\isr.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BR
                    -OWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;
                    -..\user;..\code) DEBUG PRINT(.\out_file\isr.lst) OBJECT(.\out_file\isr.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * AI8051U Opensourec Library 即（AI8051U 开源库）是一个基于官方 SDK 接口的第三方开源库
    3           * Copyright (c) 2022 SEEKFREE 逐飞科技
    4           *
    5           * 本文件是STC 开源库的一部分
    6           *
    7           * AI8051U 开源库 是免费软件
    8           * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9           * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10           *
   11           * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12           * 甚至没有隐含的适销性或适合特定用途的保证
   13           * 更多细节请参见 GPL
   14           *
   15           * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16           * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17           *
   18           * 额外注明：
   19           * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20           * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21           * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22           * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23           *
   24           * 文件名称
   25           * 公司名称          成都逐飞科技有限公司
   26           * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27           * 开发环境          MDK FOR C251
   28           * 适用平台          AI8051U
   29           * 店铺链接          https://seekfree.taobao.com/
   30           *
   31           * 修改记录
   32           * 日期              作者           备注
   33           * 2024-08-01        大W            first version
   34           ********************************************************************************************************
             -************/
   35          
   36          #include "zf_common_headfile.h"
   37          #include "FUYA.h"
   38          void DMA_UART1_IRQHandler(void) interrupt 4
   39          {
   40   1          static vuint8 dwon_count = 0;
   41   1          if (DMA_UR1R_STA & 0x01) // 接收完成
   42   1          {
   43   2              DMA_UR1R_STA &= ~0x01;      // 清标志位
   44   2              uart_rx_start_buff(UART_1); // 设置下一次接收，务必保留
   45   2      
   46   2              // 程序自动下载
   47   2              if (uart_rx_buff[UART_1][0] == 0x7F)
   48   2              {
   49   3                  if (dwon_count++ > 20)
   50   3                  {
   51   4                      IAP_CONTR = 0x60;
   52   4                  }
   53   3              }
   54   2              else
   55   2              {
C251 COMPILER V5.60.0,  isr                                                                21/11/25  22:30:33  PAGE 2   

   56   3                  dwon_count = 0;
   57   3              }
   58   2      
   59   2              if (uart1_irq_handler != NULL)
   60   2              {
   61   3                  uart1_irq_handler(uart_rx_buff[UART_1][0]);
   62   3              }
   63   2          }
   64   1      
   65   1          if (DMA_UR1R_STA & 0x02) // 数据丢弃
   66   1          {
   67   2              DMA_UR1R_STA &= ~0x02;      // 清标志位
   68   2              uart_rx_start_buff(UART_1); // 设置下一次接收，务必保留
   69   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   70   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   71   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   72   2          }
   73   1      }
   74          
   75          void DMA_UART2_IRQHandler(void) interrupt 8
   76          {
   77   1      
   78   1          if (DMA_UR2R_STA & 0x01) // 接收完成
   79   1          {
   80   2              DMA_UR2R_STA &= ~0x01;      // 清标志位
   81   2              uart_rx_start_buff(UART_2); // 设置下一次接收，务必保留
   82   2      
   83   2              if (uart2_irq_handler != NULL)
   84   2              {
   85   3                  uart2_irq_handler(uart_rx_buff[UART_2][0]);
   86   3              }
   87   2          }
   88   1      
   89   1          if (DMA_UR2R_STA & 0x02) // 数据丢弃
   90   1          {
   91   2              DMA_UR2R_STA &= ~0x02;      // 清标志位
   92   2              uart_rx_start_buff(UART_2); // 设置下一次接收，务必保留
   93   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   94   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   95   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   96   2          }
   97   1      }
   98          
   99          void DMA_UART3_IRQHandler(void) interrupt 17
  100          {
  101   1      
  102   1          if (DMA_UR3R_STA & 0x01) // 接收完成
  103   1          {
  104   2              DMA_UR3R_STA &= ~0x01;      // 清标志位
  105   2              uart_rx_start_buff(UART_3); // 设置下一次接收，务必保留
  106   2      
  107   2              if (uart3_irq_handler != NULL)
  108   2              {
  109   3      
  110   3                  uart3_irq_handler(uart_rx_buff[UART_3][0]);
  111   3              }
  112   2          }
  113   1      
  114   1          if (DMA_UR3R_STA & 0x02) // 数据丢弃
  115   1          {
  116   2              DMA_UR3R_STA &= ~0x02;      // 清标志位
  117   2              uart_rx_start_buff(UART_3); // 设置下一次接收，务必保留
  118   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  119   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  120   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  121   2          }
C251 COMPILER V5.60.0,  isr                                                                21/11/25  22:30:33  PAGE 3   

  122   1      }
  123          
  124          void DMA_UART4_IRQHandler(void) interrupt 18
  125          {
  126   1      
  127   1          if (DMA_UR4R_STA & 0x01) // 接收完成
  128   1          {
  129   2              DMA_UR4R_STA &= ~0x01;      // 清标志位
  130   2              uart_rx_start_buff(UART_4); // 设置下一次接收，务必保留
  131   2      
  132   2              if (uart4_irq_handler != NULL)
  133   2              {
  134   3                  uart4_irq_handler(uart_rx_buff[UART_4][0]);
  135   3              }
  136   2          }
  137   1      
  138   1          if (DMA_UR4R_STA & 0x02) // 数据丢弃
  139   1          {
  140   2              DMA_UR4R_STA &= ~0x02;      // 清标志位
  141   2              uart_rx_start_buff(UART_4); // 设置下一次接收，务必保留
  142   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  143   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  144   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  145   2          }
  146   1      }
  147          
  148          uint32 time_0 = 0; // 时间计数器
  149          int left_motor = 0, right_motor = 0;
  150          float motor = 0;
  151          static int test_time = 0;
  152          int flat_statr = 0;
  153          static int flat_statr_date = 0;
  154          void TM0_IRQHandler() interrupt 1
  155          {
  156   1          TIM0_CLEAR_FLAG;
  157   1              if(!P32)IAP_CONTR=0x60;//判断快速烧录
  158   1              scan_track_max_value(); //获取电感最大值
  159   1              read_AD();              // 读取并处理电感数据
  160   1          Encoder_get();
  161   1              Prepare_Data();
  162   1              lost_lines();
  163   1          motor = PID_Positional_Calculate(&motors_pid.Positional_PID, Err, -imu660ra_gyro_z * 0.01);
  164   1          left_motor = (int)PID_Calculate(&motors_pid.left_PID, speed_run - motor, speed_l); // 速度最大值为110
  165   1          right_motor = (int)PID_Calculate(&motors_pid.right_PID, speed_run + motor, speed_r);
  166   1              if (flat_statr >= 2&&lost_spto==0)
  167   1              {
  168   2                      motor_output(left_motor, right_motor);
  169   2              }
  170   1      //    test();
  171   1          if (tim0_irq_handler != NULL)
  172   1          {
  173   2              tim0_irq_handler();
  174   2          }
  175   1      }
  176          void TM1_IRQHandler() interrupt 3
  177          {
  178   1          TIM1_CLEAR_FLAG;
  179   1          IMUupdate(&Gyr_filt, &Acc_filt, &Att_Angle);
  180   1              dianya_adc();
  181   1              flat_statr_date++;
  182   1              if (P35 == 0&&flat_statr_date>50)
  183   1              {
  184   2                      flat_statr++;
  185   2                      flat_statr_date = 0;
  186   2              }
  187   1              if (flat_statr >= 1&&lost_spto==0&&start_flag==1)
C251 COMPILER V5.60.0,  isr                                                                21/11/25  22:30:33  PAGE 4   

  188   1              {
  189   2                      fuya_update_simple();
  190   2              }
  191   1          if (tim1_irq_handler != NULL)
  192   1          {
  193   2              tim1_irq_handler();
  194   2          }
  195   1      }
  196          void TM2_IRQHandler() interrupt 12
  197          {
  198   1          TIM2_CLEAR_FLAG;
  199   1      
  200   1          if (tim2_irq_handler != NULL)
  201   1          {
  202   2              tim2_irq_handler();
  203   2          }
  204   1      }
  205          void TM3_IRQHandler() interrupt 19
  206          {
  207   1          TIM3_CLEAR_FLAG;
  208   1      
  209   1          if (tim3_irq_handler != NULL)
  210   1          {
  211   2              tim3_irq_handler();
  212   2          }
  213   1      }
  214          
  215          void TM4_IRQHandler() interrupt 20
  216          {
  217   1          TIM4_CLEAR_FLAG;
  218   1      
  219   1          if (tim4_irq_handler != NULL)
  220   1          {
  221   2              tim4_irq_handler();
  222   2          }
  223   1      }
  224          
  225          void TM11_IRQHandler() interrupt 24
  226          {
  227   1          TIM11_CLEAR_FLAG;
  228   1      
  229   1          if (tim11_irq_handler != NULL)
  230   1          {
  231   2              tim11_irq_handler();
  232   2          }
  233   1      }
  234          
  235          // #define     INT0_VECTOR             0       //0003H
  236          // #define     TMR0_VECTOR             1       //000BH
  237          // #define     INT1_VECTOR             2       //0013H
  238          // #define     TMR1_VECTOR             3       //001BH
  239          // #define     UART1_VECTOR            4       //0023H
  240          // #define     ADC_VECTOR              5       //002BH
  241          // #define     LVD_VECTOR              6       //0033H
  242          // #define     PCA_VECTOR              7       //003BH
  243          // #define     UART2_VECTOR            8       //0043H
  244          // #define     SPI_VECTOR              9       //004BH
  245          // #define     INT2_VECTOR             10      //0053H
  246          // #define     INT3_VECTOR             11      //005BH
  247          // #define     TMR2_VECTOR             12      //0063H
  248          // #define     USER_VECTOR             13      //006BH
  249          // #define     INT4_VECTOR             16      //0083H
  250          // #define     UART3_VECTOR            17      //008BH
  251          // #define     UART4_VECTOR            18      //0093H
  252          // #define     TMR3_VECTOR             19      //009BH
  253          // #define     TMR4_VECTOR             20      //00A3H
C251 COMPILER V5.60.0,  isr                                                                21/11/25  22:30:33  PAGE 5   

  254          // #define     CMP_VECTOR              21      //00ABH
  255          // #define     I2C_VECTOR              24      //00C3H
  256          // #define     USB_VECTOR              25      //00CBH
  257          // #define     PWMA_VECTOR             26      //00D3H
  258          // #define     PWMB_VECTOR             27      //00DBH
  259          
  260          // #define     RTC_VECTOR              36      //0123H
  261          // #define     P0INT_VECTOR            37      //012BH
  262          // #define     P1INT_VECTOR            38      //0133H
  263          // #define     P2INT_VECTOR            39      //013BH
  264          // #define     P3INT_VECTOR            40      //0143H
  265          // #define     P4INT_VECTOR            41      //014BH
  266          // #define     P5INT_VECTOR            42      //0153H
  267          // #define     P6INT_VECTOR            43      //015BH
  268          // #define     P7INT_VECTOR            44      //0163H
  269          // #define     DMA_M2M_VECTOR          47      //017BH
  270          // #define     DMA_ADC_VECTOR          48      //0183H
  271          // #define     DMA_SPI_VECTOR          49      //018BH
  272          // #define     DMA_UR1T_VECTOR         50      //0193H
  273          // #define     DMA_UR1R_VECTOR         51      //019BH
  274          // #define     DMA_UR2T_VECTOR         52      //01A3H
  275          // #define     DMA_UR2R_VECTOR         53      //01ABH
  276          // #define     DMA_UR3T_VECTOR         54      //01B3H
  277          // #define     DMA_UR3R_VECTOR         55      //01BBH
  278          // #define     DMA_UR4T_VECTOR         56      //01C3H
  279          // #define     DMA_UR4R_VECTOR         57      //01CBH
  280          // #define     DMA_LCM_VECTOR          58      //01D3H
  281          // #define     LCM_VECTOR              59      //01DBH
  282          // #define     DMA_I2CT_VECTOR         60      //01E3H
  283          // #define     DMA_I2CR_VECTOR         61      //01EBH
  284          // #define     I2S_VECTOR              62      //01F3H
  285          // #define     DMA_I2ST_VECTOR         63      //01FBH
  286          // #define     DMA_I2SR_VECTOR         64      //0203H
  287          // #define     DMA_QSPI_VECTOR         65      //020BH
  288          // #define     QSPI_VECTOR             66      //0213H
  289          // #define     TMR11_VECTOR            67      //021BH
  290          // #define     DMA_PWMAT_VECTOR        72      //0243H
  291          // #define     DMA_PWMAR_VECTOR        73      //024BH


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1456     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        19     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        59     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
