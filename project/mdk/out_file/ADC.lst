C251 COMPILER V5.60.0,  ADC                                                                23/11/25  21:54:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\out_file\ADC.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\ADC.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BR
                    -OWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;
                    -..\user;..\code) DEBUG PRINT(.\out_file\ADC.lst) OBJECT(.\out_file\ADC.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #define AD_VAL_MAX 3500 // µç¸Ð×î´óÖµÉÏÏÞ£¨ADC Ô­Ê¼¼ÆÊý×î´óÖµ£¬Ê¹ÓÃÕûÊý£©
    3          #define NUM 4           // µç¸ÐÊýÁ¿4
    4          #define SORT_LENGTH 4   // ÅÅÐòÊý×é³¤¶È
    5          
    6          /*********************************************
    7                       µç¸ÐÅÅ²¼
    8                        ËÄµç¸Ð
    9          
   10              ¡ª     l       l     ¡ª
   11          
   12             ad1   ad2     ad3   ad4
   13          
   14           *********************************************/
   15          static uint16 AD_value[NUM][SORT_LENGTH] = {{0}};                                // ´æ´¢µç¸ÐÔ­Ê¼ÖµµÄ¶þÎ¬Ê
             -ý×é£¨ÕûÊý£©
   16          static uint16 adtemp = 0;                                                        // ÅÅÐòÁÙÊ±±äÁ¿£¨ÕûÊý£©
   17          static uint32 ad_sum[NUM] = {0};                                                 // µç¸ÐÖµÇóºÍ£¨·ÀÖ¹Òç³ö£
             -¬Ê¹ÓÃ32Î»£©
   18          static uint16 ad_ave[NUM] = {0};                                                 // µç¸ÐÖµÖÐÖµ£¨ÕûÊý£©
   19          static uint16 AD_V[NUM] = {0}, AD_last[NUM] = {0};                               // µç¸ÐÖµ´¦ÀíºóµÄ½á¹û£¨Õ
             -ûÊý£©
   20          uint16 RAW[NUM] = {0};                                                           // µç¸ÐÔ­Ê¼Öµ£¨ÕûÊý£¬¹©Ï
             -ÔÊ¾/±ê¶¨£©
   21          uint16 ad1 = 0;                                                                  // µÚ1¸öµç¸ÐÖµ£¨¹éÒ»»¯ºó
             -£¬0-100£©
   22          uint16 ad2 = 0;                                                                  // µÚ2¸öµç¸ÐÖµ£¨¹éÒ»»¯ºó
             -£¬0-100£©
   23          uint16 ad3 = 0;                                                                  // µÚ6¸öµç¸ÐÖµ£¨¹éÒ»»¯ºó
             -£¬0-100£©
   24          uint16 ad4 = 0;                                                                  // µÚ7¸öµç¸ÐÖµ£¨¹éÒ»»¯ºó
             -£¬0-100£©
   25          static const uint16 MAX[NUM] = {AD_VAL_MAX, AD_VAL_MAX, AD_VAL_MAX, AD_VAL_MAX}; // ¸÷µç¸Ð×î´óÖµ£¨³£Á¿£©
   26          uint16 MA[NUM] = {0};                                                            // É¨Ãè¼ÇÂ¼µÄ×î´óÖµ£¨ÕûÊ
             -ý£©
   27          float Err = 0;                                                                   // µ±Ç°Æ«²îÖµ£¨ÕûÊý£¬¹© 
             -PID_Direction Ê¹ÓÃ£©
   28          static const int limit = 100;                                                    // Æ«²îÏÞ·ù£¨ÕûÊý£©
   29          void dispose(void)
   30          {
   31   1          float denom = 0;
   32   1          denom = A_1 * (ad1 + ad4) + C_l * func_abs((int)ad2 - (int)ad3);
   33   1          Err = limit * (A_1 * (ad1 - ad4) + B_1 * (ad2 - ad3)) / denom;
   34   1      }
   35          
   36          /**
   37           * @brief É¨ÃèÈüµÀ»ñÈ¡µç¸Ð×î´óÖµ
   38           * @details »ñÈ¡¸÷¸öµç¸ÐµÄµ±Ç°Öµ£¬²¢¸üÐÂ¼ÇÂ¼µÄ×î´óÖµ
   39           * @note ÓÃÓÚµç¸Ð±ê¶¨ºÍ¹éÒ»»¯¼ÆËãµÄ²Î¿¼Öµ
   40           */
   41          void scan_track_max_value(void)
   42          {
   43   1          int i = 0;
   44   1          // ¶ÁÈ¡ ADC Ô­Ê¼Öµ£¨uint16£©£¬È«³ÌÊ¹ÓÃÕûÊý£¬±ÜÃâ²»±ØÒªµÄÀàÐÍ×ª»»
   45   1          RAW[0] = adc_convert(ADC_CH1_P11); // ¶ÁÈ¡µÚ1¸öµç¸ÐADÖµ
   46   1          RAW[1] = adc_convert(ADC_CH0_P10); // ¶ÁÈ¡µÚ2¸öµç¸ÐADÖµ
   47   1          RAW[2] = adc_convert(ADC_CH8_P00); // ¶ÁÈ¡µÚ3¸öµç¸ÐADÖµ
C251 COMPILER V5.60.0,  ADC                                                                23/11/25  21:54:33  PAGE 2   

   48   1          RAW[3] = adc_convert(ADC_CH9_P01); // ¶ÁÈ¡µÚ4¸öµç¸ÐADÖµ
   49   1      
   50   1          for (i = 0; i < NUM; i++)
   51   1          {
   52   2              // Èç¹ûµ±Ç°Öµ´óÓÚ¼ÇÂ¼µÄ×î´óÖµ£¬Ôò¸üÐÂ×î´óÖµ
   53   2              if (RAW[i] > MA[i])
   54   2              {
   55   3                  MA[i] = RAW[i];
   56   3              }
   57   2          }
   58   1      }
   59          
   60          /**
   61           * @brief ¶ÁÈ¡²¢´¦Àíµç¸ÐÊý¾Ý
   62           * @details ¶à´Î²ÉÑù²¢ÅÅÐòÂË²¨£¬¶Ôµç¸ÐÖµ½øÐÐ¹éÒ»»¯´¦Àí²¢¼ÆËãÆ«²î
   63           * @note ºËÐÄµç¸Ð´¦Àíº¯Êý£¬ÓÃÓÚÈüµÀÊ¶±ðºÍÑ­¼£¿ØÖÆ
   64           */
   65          void read_AD(void)
   66          {
   67   1          int i, j, k;
   68   1          uint16 AD_ONE[NUM] = {0}; // ¹éÒ»»¯ºóµÄµç¸ÐÖµ£¨0-100£©£¬Ê¹ÓÃÕûÊý¶¨µã
   69   1          int min_idx = 0;
   70   1      
   71   1          // 1. ¶à´Î²ÉÑùµç¸ÐÖµ
   72   1          for (i = 0; i < SORT_LENGTH; i++)
   73   1          {
   74   2              AD_value[0][i] = adc_convert(ADC_CH1_P11); // ²É¼¯µÚ1¸öµç¸Ð£¨uint16£©
   75   2              AD_value[1][i] = adc_convert(ADC_CH0_P10); // ²É¼¯µÚ2¸öµç¸Ð£¨uint16£©
   76   2              AD_value[2][i] = adc_convert(ADC_CH8_P00); // ²É¼¯µÚ6¸öµç¸Ð£¨uint16£©
   77   2              AD_value[3][i] = adc_convert(ADC_CH9_P01); // ²É¼¯µÚ7¸öµç¸Ð£¨uint16£©
   78   2          }
   79   1      
   80   1          // 2. ¶ÔÃ¿¸öµç¸ÐµÄ²ÉÑùÖµ½øÐÐÅÅÐò£¨Ñ¡ÔñÅÅÐòËã·¨£©
   81   1          for (i = 0; i < NUM; i++)
   82   1          {
   83   2              for (j = 0; j < SORT_LENGTH - 1; j++)
   84   2              {
   85   3                  min_idx = j;
   86   3                  for (k = j + 1; k < SORT_LENGTH; k++)
   87   3                  {
   88   4                      if (AD_value[i][k] < AD_value[i][min_idx])
   89   4                      {
   90   5                          min_idx = k;
   91   5                      }
   92   4                  }
   93   3                  if (min_idx != j)
   94   3                  {
   95   4                      adtemp = AD_value[i][j];
   96   4                      AD_value[i][j] = AD_value[i][min_idx];
   97   4                      AD_value[i][min_idx] = adtemp;
   98   4                  }
   99   3              }
  100   2      
  101   2              // 3. ÖÐÖµ¼ÆËã£¨ÕûÊý£©- Êý×é³¤¶ÈÎª4£¬È¡ÖÐ¼äÁ½¸öÖµ(ÏÂ±ê1ºÍ2)µÄÆ½¾ùÖµ
  102   2              ad_sum[i] = (uint32)AD_value[i][1] + (uint32)AD_value[i][2];
  103   2              ad_ave[i] = (uint16)((ad_sum[i] + 1u) / 2u); // +1×öËÄÉáÎåÈë
  104   2              AD_value[i][SORT_LENGTH - 1] = ad_ave[i];
  105   2          }
  106   1      
  107   1          memset(ad_sum, 0, sizeof(ad_sum));
  108   1      
  109   1          // 4. ¼ÆËãÃ¿¸öµç¸ÐµÄ×îÖÕÖµ²¢ÏÞ·ù
  110   1          for (i = 0; i < NUM; i++)
  111   1          {
  112   2              for (j = 0; j < SORT_LENGTH; j++)
  113   2              {
C251 COMPILER V5.60.0,  ADC                                                                23/11/25  21:54:33  PAGE 3   

  114   3                  ad_sum[i] += (uint32)AD_value[i][j];
  115   3              }
  116   2              AD_V[i] = (uint16)(ad_sum[i] / SORT_LENGTH); // ÇóÆ½¾ùÖµ£¨ÕûÊý£©
  117   2              RAW[i] = AD_V[i];                            // ±£´æÔ­Ê¼ADÖµ£¨ÕûÊý£©
  118   2              if (AD_V[i] > MAX[i])                        // ÏÞ·ù´¦Àí
  119   2              {
  120   3                  AD_V[i] = MAX[i];
  121   3              }
  122   2          }
  123   1      
  124   1          // 5. ¹éÒ»»¯´¦Àí£¨×ª»»Îª0-100·¶Î§£©
  125   1          for (i = 0; i < NUM; i++)
  126   1          {
  127   2              // Ê¹ÓÃÕûÊý¶¨µã£º°Ù·Ö±È = AD_V / MAX * 100
  128   2              AD_ONE[i] = (uint16)((100u * (uint32)AD_V[i]) / (uint32)MAX[i]);
  129   2          }
  130   1      
  131   1          // 6. ½«´¦ÀíºóµÄÖµ¸³¸ø¸÷¸öµç¸Ð±äÁ¿
  132   1          ad1 = AD_ONE[0];
  133   1          ad2 = AD_ONE[1];
  134   1          ad3 = AD_ONE[2];
  135   1          ad4 = AD_ONE[3];
  136   1          dispose(); // ´¦Àíµç¸ÐÊý¾Ý£¬¼ÆËãÆ«²îÖµ
  137   1      }
  138          // µçÑ¹²ÉÑùÖµ£¨µ¥Î»£ºmV£©£¬Ê¹ÓÃÕûÊý±ÜÃâ¸¡µãÔËËã
  139          uint16 dianya = 0;
  140          void dianya_adc(void)
  141          {
  142   1          // Éè¼ÆËµÃ÷£ºÔ­¹«Ê½Îª V = ADC * 0.0092£¨µ¥Î» V£©£¬¸ÄÎª mV µÄÕûÊý±íÊ¾£ºmV = ADC * 9.2 ¡Ö (ADC * 92) / 
             -10
  143   1          static int32 dianya_count = 0;
  144   1          uint16 adc_raw = adc_convert(ADC_CH13_P05);
  145   1          dianya = (uint16)(((uint32)adc_raw * 92u) / 10u); // mV ÕûÊý±íÊ¾£¬±ÜÃâ¸¡µã³Ë·¨
  146   1      
  147   1          pwm_set_duty(PWMA_CH4N_P07, 0);
  148   1          // Ô­ãÐÖµ 7.6V ¸ÄÎª 7600mV
  149   1          if (dianya < 7600u)
  150   1          {
  151   2              dianya_count++;
  152   2          }
  153   1          if (dianya_count > 2000)
  154   1          {
  155   2              dianya_count = 0;
  156   2              pwm_set_duty(PWMA_CH4N_P07, 3000);
  157   2          }
  158   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1964     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       132     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       201     ------
End of Module Information.

C251 COMPILER V5.60.0,  ADC                                                                23/11/25  21:54:33  PAGE 4   


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
