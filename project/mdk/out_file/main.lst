C251 COMPILER V5.60.0,  main                                                               30/11/25  21:27:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\out_file\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\user\main.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\main.lst) TABS(2) OBJECT(.\out_file\main.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #include <type.h>
    3          #include "vofa.h"
    4          #include <stdlib.h>
    5          
    6          // 打印与调试函数声明
    7          void printf_adc();
    8          void printf_imu();
    9          void printf_date();
   10          void printf_speed_test();
   11          void task1ms(void)
   12          {
   13   1      
   14   1      }
   15          void task10ms(void)
   16          {
   17   1        
   18   1      }
   19          void task100ms(void)
   20          {
   21   1        char vofa_cmd[32]; // VOFA 命令缓存
   22   1        // ========== 处理 VOFA 命令 ==========
   23   1        // 从 FIFO 读取串口数据，使用系统提供的 wireless_uart_read_buffer
   24   1        vofa_parse_from_fifo();
   25   1      
   26   1        //       检查是否解析到完整命令
   27   1        if (vofa_get_command(vofa_cmd, 32))
   28   1        {
   29   2          handle_vofa_command(vofa_cmd);
   30   2        }
   31   1      
   32   1        // ========== 数据发送到 VOFA+ ==========
   33   1        // 使用 FireWater 协议发送数据
   34   1        // printf("%f,%f,%f,%f\n", speed_l, speed_r, test_speed, PID.steer.output);
   35   1      
   36   1        // ========== 显示调试功能（按需选择） ==========
   37   1        // printf_date();
   38   1        // printf_adc();
   39   1        // printf_imu();
   40   1        // printf_speed_test();
   41   1      //     Keystroke_Menu();
   42   1      }
   43          void task1000ms(void)
   44          {
   45   1        
   46   1      }
   47          typedef void(*pFunc)(void);
   48          
   49          struct taskconfig {
   50            u8 ID;
   51            u16 Period;
   52            u16 Cnt;
   53            bool_t Event;
   54            pFunc pTaskFunc;
   55          };
   56          #define TASKFUNCTION(ID, Period, Cnt, Event, fn) {ID, Period, Cnt, Event, fn}
   57          struct taskconfig gTaskList[] = {
C251 COMPILER V5.60.0,  main                                                               30/11/25  21:27:04  PAGE 2   

   58            TASKFUNCTION(1, 1,    0, 0, task1ms),
   59            TASKFUNCTION(2, 10,   1, 0, task10ms),
   60            TASKFUNCTION(3, 100,  5, 0, task100ms),
   61            TASKFUNCTION(4, 1000, 7, 0, task1000ms)
   62          };
   63          #define TASKSIZEOF  (sizeof(gTaskList)/sizeof(struct taskconfig))
   64          struct taskconfig* pTaskEnd = &gTaskList[TASKSIZEOF-1];
   65          VOL_U8 gTaskStick = 0;
   66          void main_task(void)
   67          {
   68   1        struct taskconfig* pTask = &gTaskList[0];
   69   1        if (gTaskStick < MODULATE1MS) {
   70   2          return;
   71   2        }
   72   1        gTaskStick = 0;
   73   1      
   74   1        for (;pTask <= pTaskEnd; pTask++) {
   75   2          if (++pTask->Cnt >= pTask->Period) {
   76   3            pTask->Event = 1;
   77   3          }
   78   2          if (pTask->Event) {
   79   3            pTask->pTaskFunc();
   80   3            pTask->Cnt = 0;
   81   3            pTask->Event = 0;
   82   3          }
   83   2        }
   84   1      }
   85          
   86          
   87          void main()
   88          {
   89   1      
   90   1      
   91   1        clock_init(SYSTEM_CLOCK_40M); // 时钟初始化
   92   1        debug_init();         // 调试接口初始化
   93   1        P32 = 1;            // 上电安全记录（示例）
   94   1      
   95   1        // 初始化（wireless_uart_init 已在 int_user 中完成）
   96   1        int_user();
   97   1        vofa_init(); // 初始化 VOFA 通信（可选）
   98   1      
   99   1        while (1)
  100   1        {
  101   2          main_task();
  102   2        }
  103   1      }
  104          
  105          // 原有的数据显示函数（已部分调整）
  106          void printf_date()
  107          {
  108   1        // 优化：Err 与电感归一化值使用整数显示，避免浮点格式化开销
  109   1        ips114_show_int32(1 * 24, 18 * 0, Err, 3);
  110   1        ips114_show_int32(1 * 24, 18 * 1, ad1, 3);
  111   1        ips114_show_int32(1 * 24, 18 * 2, ad2, 3);
  112   1        ips114_show_int32(1 * 24, 18 * 3, ad3, 3);
  113   1        ips114_show_int32(1 * 24, 18 * 4, ad4, 3);
  114   1      
  115   1        ips114_show_float(3 * 24, 18 * 0, PID.steer.output, 3, 1);
  116   1        ips114_show_float(3 * 24, 18 * 1, speed_run + PID.steer.output, 3, 1);
  117   1        ips114_show_float(3 * 24, 18 * 2, speed_run - PID.steer.output, 3, 1);
  118   1      
  119   1        // 电压使用 mV 整数显示（dianya 已在 ADC.c 转为 mV 整数）
  120   1        ips114_show_int32(6 * 24, 18 * 1, dianya, 5);
  121   1      }
  122          
  123          void printf_adc()
C251 COMPILER V5.60.0,  main                                                               30/11/25  21:27:04  PAGE 3   

  124          {
  125   1        // 电感归一化值（0-100）整数显示
  126   1        ips114_show_int32(1 * 24, 18 * 0, ad1, 3);
  127   1        ips114_show_int32(1 * 24, 18 * 1, ad2, 3);
  128   1        ips114_show_int32(1 * 24, 18 * 2, ad3, 3);
  129   1        ips114_show_int32(1 * 24, 18 * 3, ad4, 3);
  130   1      
  131   1        ips114_show_int32(1 * 24, 18 * 6, Err, 4);
  132   1      
  133   1        // 原始 ADC 计数显示（整数）
  134   1        ips114_show_int32(3 * 24, 18 * 0, RAW[0], 4);
  135   1        ips114_show_int32(3 * 24, 18 * 1, RAW[1], 4);
  136   1        ips114_show_int32(3 * 24, 18 * 2, RAW[2], 4);
  137   1        ips114_show_int32(3 * 24, 18 * 3, RAW[3], 4);
  138   1      
  139   1        // 标定最大值显示（整数）
  140   1        ips114_show_int32(7 * 24, 18 * 0, MA[0], 4);
  141   1        ips114_show_int32(7 * 24, 18 * 1, MA[1], 4);
  142   1        ips114_show_int32(7 * 24, 18 * 2, MA[2], 4);
  143   1        ips114_show_int32(7 * 24, 18 * 3, MA[3], 4);
  144   1      }
  145          
  146          void printf_imu()
  147          {
  148   1        ips114_show_float(4 * 24, 18 * 0, Gyr_filt.X, 4, 2);
  149   1        ips114_show_float(4 * 24, 18 * 1, Gyr_filt.Y, 4, 2);
  150   1        ips114_show_float(4 * 24, 18 * 2, Gyr_filt.Z, 4, 2);
  151   1        ips114_show_float(4 * 24, 18 * 4, Acc_filt.X, 4, 2);
  152   1        ips114_show_float(4 * 24, 18 * 5, Acc_filt.Y, 4, 2);
  153   1        ips114_show_float(4 * 24, 18 * 6, Acc_filt.Z, 4, 2);
  154   1        ips114_show_float(7 * 24, 18 * 0, vx, 4, 2);
  155   1        ips114_show_float(7 * 24, 18 * 1, vy, 4, 2);
  156   1        ips114_show_float(7 * 24, 18 * 2, vz, 4, 2);
  157   1        ips114_show_int32(7 * 24, 18 * 4, fuya_date, 4);
  158   1        ips114_show_int32(7 * 24, 18 * 5, phase, 4);
  159   1      }
  160          
  161          void printf_speed_test()
  162          {
  163   1        ips114_show_float(0, 0, test_speed, 6, 1);
  164   1        ips114_show_float(0, 15, PID.steer.output, 6, 1);
  165   1        ips114_show_float(0, 35, speed_l, 6, 1);
  166   1        ips114_show_float(0, 55, speed_r, 6, 1);
  167   1        ips114_show_int32(0, 75, imu660ra_gyro_z, 6);
  168   1        ips114_show_int32(0, 95, imu660ra_gyro_z * 0.01, 6);
  169   1        printf("%f,%f,%f,%f\n", test_speed, speed_l, speed_r, 0.0);
  170   1      }
  171          
  172          void printf_butten_test()
  173          {
  174   1        ips114_show_int32(4 * 24, 18 * 0, P33, 1);
  175   1        ips114_show_int32(4 * 24, 18 * 1, P34, 1);
  176   1        ips114_show_int32(4 * 24, 18 * 2, P35, 1);
  177   1        ips114_show_int32(4 * 24, 18 * 4, P36, 1);
  178   1        ips114_show_int32(4 * 24, 18 * 5, P37, 1);
  179   1        ips114_show_int32(4 * 24, 18 * 6, flat_statr, 2);
  180   1      }
  181          
  182          /*******************************************************************************
  183           * VOFA+ 使用示例
  184           *
  185           * 左轮 PID_Direction:
  186           *   L_KP=100!
  187           *   L_KI=40!
  188           *   L_KD=0!
  189           *
C251 COMPILER V5.60.0,  main                                                               30/11/25  21:27:04  PAGE 4   

  190           * 右轮 PID_Direction:
  191           *   R_KP=100!
  192           *   R_KI=40!
  193           *
  194           * 位置式 PID_Direction:
  195           *   P_KP=0.3!
  196           *   P_KI=0.1!
  197           *   P_KD=4!
  198           *   KD_GYRO=2.5!
  199           *
  200           * 运行控制:
  201           *   SPEED=50!      - 设置目标速度
  202           *   START!         - 启动电机
  203           *   STOP!          - 停止电机
  204           *   SAVE!          - 保存参数
  205           *   INFO!          - 查看当前参数
  206           *   RESET!         - 软复位系统
  207           ******************************************************************************/
  208           
  209           
  210           


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1904     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        77     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        71     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
