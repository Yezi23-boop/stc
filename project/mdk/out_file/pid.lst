C251 COMPILER V5.60.0,  pid                                                                21/11/25  22:30:35  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pid
OBJECT MODULE PLACED IN .\out_file\pid.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\pid.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BR
                    -OWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;
                    -..\user;..\code) DEBUG PRINT(.\out_file\pid.lst) OBJECT(.\out_file\pid.obj) 

stmt  level    source

    1          #include "pid.h"
    2          PID_struct motors_pid;
    3          LowPassFilter_t encoder_l;
    4          LowPassFilter_t encoder_r;
    5          float delta_output = 0, speed_l = 0, speed_r = 0, max_integral = 0;
    6          void PID_Init(PID *pid, float Kp, float Ki, float Kd, float max_output,float min_output)
    7          {
    8   1          pid->Kp = Kp;
    9   1          pid->Ki = Ki;
   10   1          pid->Kd = Kd;
   11   1          pid->error = 0.0f;
   12   1          pid->prev_error = 0.0f;
   13   1          pid->prev2_error = 0.0f;
   14   1          pid->output = 0.0f;
   15   1          pid->integral = 0.0f;
   16   1          pid->max_output = max_output;
   17   1              pid->min_output = min_output;
   18   1      }
   19          // 编码器读取
   20          void Encoder_get(void)
   21          {
   22   1          // 读取编码器计数值并转换为速度（乘以系数0.2调整单位）
   23   1          speed_l = encoder_get_count(TIM4_ENCOEDER) * 0.2f;  // 左轮速度
   24   1          speed_r = -encoder_get_count(TIM3_ENCOEDER) * 0.2f; // 右轮速度（负号用于方向调整）
   25   1          low_pass_filter_mt(&encoder_l, &speed_l, 0.8);
   26   1          low_pass_filter_mt(&encoder_r, &speed_r, 0.8);
   27   1          // 清除编码器计数，准备下一次计数
   28   1          encoder_clear_count(TIM3_ENCOEDER);
   29   1          encoder_clear_count(TIM4_ENCOEDER);
   30   1      }
   31          // 增量式PID
   32          float PID_Calculate(PID *pid, float setpoint, float actual)
   33          {
   34   1          // 计算当前误差
   35   1          pid->error = setpoint - actual;
   36   1      
   37   1          // 计算增量输出
   38   1          delta_output = pid->Kp * (pid->error - pid->prev_error) + pid->Ki * pid->error + pid->Kd * (pid->erro
             -r - 2.0f * pid->prev_error + pid->prev2_error);
   39   1      
   40   1          // 更新输出值
   41   1          pid->output += delta_output;
   42   1      
   43   1          // 输出限幅
   44   1          if (pid->output > pid->max_output)
   45   1          {
   46   2              pid->output = pid->max_output;
   47   2          }
   48   1          else if (pid->output < -pid->max_output)
   49   1          {
   50   2              pid->output = -pid->max_output;
   51   2          }
   52   1      
   53   1          // 更新误差历史
   54   1          pid->prev2_error = pid->prev_error;
   55   1          pid->prev_error = pid->error;
   56   1      
C251 COMPILER V5.60.0,  pid                                                                21/11/25  22:30:35  PAGE 2   

   57   1          return pid->output;
   58   1      }
   59          
   60          // 位置式PID计算
   61          float PID_Positional_Calculate(PID *pid, float actual, float imu)
   62          {
   63   1          // 计算当前误差
   64   1          pid->error = actual;
   65   1      
   66   1          // 更新积分项（抗积分饱和处理）
   67   1      //    pid->integral += pid->error;
   68   1      
   69   1      //    //    // 限制积分项，防止积分饱和
   70   1      //    if (pid->integral = pid->max_output)
   71   1      //    {
   72   1      //        pid->integral = 0;
   73   1      //    }
   74   1      
   75   1          // 计算位置式PID输出
   76   1          pid->output = pid->Kp * pid->error + pid->Ki * imu + pid->Kd * (pid->error - pid->prev_error);
   77   1      
   78   1          // 输出限幅
   79   1          if (pid->output > pid->max_output)
   80   1          {
   81   2              pid->output = pid->max_output;
   82   2          }
   83   1          else if (pid->output < -pid->min_output)
   84   1          {
   85   2              pid->output = -pid->min_output;
   86   2          }
   87   1      
   88   1          // 更新误差历史
   89   1          pid->prev_error = pid->error;
   90   1      
   91   1          return pid->output;
   92   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1583     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       192     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        36     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
