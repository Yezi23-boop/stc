C251 COMPILER V5.60.0,  FUYA                                                               23/11/25  21:54:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE FUYA
OBJECT MODULE PLACED IN .\out_file\FUYA.obj
COMPILER INVOKED BY: D:\keil_5\C251\BIN\C251.EXE ..\user\FUYA.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\FUYA.lst) OBJECT(.\out_file\FUYA.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #include <math.h>
    3          
    4          // 全局变量：负压状态与历史数据
    5          int fuya_date = 0.0f;              // 当前输出给负压执行器的平滑占空比
    6          float fuya_date_factor = 0.0f; // 未滤波的目标占空比，用于调试观察
    7          uint8 phase = 0;                           // 当前阶段编号（0~4）
    8          
    9          // 负压基准参数（单位：占空比，0~10000）――根据结构四个切点标定
   10          // #define DUTY_BOTTOM 500.0f            // 下切点（平地）基准
   11          float DUTY_BOTTOM = 0;                   // 下切点（平地）基准
   12          #define DUTY_LEFT 4500.0f                // 左切点（左侧竖墙）基础值
   13          #define DUTY_RIGHT 4000.0f               // 右切点（右侧竖墙）基础值
   14          #define DUTY_TOP 4000.0f                 // 上切点（倒立）基准
   15          #define PREFERENCE_OFFSET 500.0f // 前向优待最大偏移量（±250）
   16          
   17          // 姿态阈值（基于 IMU 单位向量 vzc/vxc 划分场景）
   18          #define VZC_GROUND_THRESH 0.93f
   19          #define VZC_VERTICAL_THRESH 0.15f
   20          #define VZC_INVERT_THRESH -0.9f
   21          #define VXC_PLANE_MARGIN 0.06f
   22          #define VXC_WALL_MARGIN 0.06f
   23          #define VXC_WALL_RELEASE 0.02f
   24          
   25          // 平滑系数 alpha：不同阶段的响应速度需求不同，单独配置
   26          #define ALPHA_UP1 0.92f    // 阶段0/1：平地及平地上墙，需迅速贴合目标
   27          #define ALPHA_UP2 0.65f    // 阶段2：左墙向天花板，提高倒立响应
   28          #define ALPHA_DOWN1 0.55f  // 阶段3：天花板向右墙，加快释放速度
   29          #define ALPHA_DOWN2 0.45f  // 阶段4：右墙向平地，仍保持适度柔和但更快
   30          #define ALPHA_DEFAULT 0.8f // 过渡阶段默认响应
   31          
   32          // 负压输出限幅（硬件/安全双重限制）
   33          #define DUTY_MIN 1800.0f // 最低保障占空比，防止吸力过小
   34          #define DUTY_MAX 4000.0f // 允许的最大占空比（含前向优待）
   35          
   36          /**
   37           * @brief 负压吸附系统初始化函数
   38           */
   39          void fuya_Init(void)
   40          {
   41   1              pwm_init(PWMA_CH2N_P03, 17000, 0); // 初始化风扇PWM（40kHz）
   42   1      }
   43          
   44          /**
   45           * @brief 输出占空比到风扇（负压吸附执行器）
   46           * @param pwm 目标占空比（需为非负值，因为风扇/泵通常只正向工作）
   47           * @note 控制风扇转速，占空比越大，吸力越强
   48           */
   49          void fuya_motor_output(int pwm)
   50          {
   51   1              // 简单限幅，避免越界
   52   1              if (pwm < 0)
   53   1                      pwm = 0;
   54   1              if (pwm > 3000)
   55   1                      pwm = 3000;
   56   1              pwm_set_duty(PWMA_CH2N_P03, (uint32)pwm);
   57   1      }
C251 COMPILER V5.60.0,  FUYA                                                               23/11/25  21:54:33  PAGE 2   

   58          
   59          /**
   60           * @brief 判断当前所处阶段（基于 vzc/vxc 组合）
   61           * @return 阶段编号：0=平地，1=平地上墙，2=墙上天花板，3=天花板下墙，4=墙下平地
   62           * @note 阈值取自 VZC/VXC，保证五段互斥并覆盖整圈运动
   63           */
   64          uint8 get_current_phase(float vzc, float vxc)
   65          {
   66   1              if (vzc >= VZC_GROUND_THRESH && func_abs(vxc) <= VXC_PLANE_MARGIN)
   67   1              {
   68   2                      return 0; // 平地
   69   2              }
   70   1              else if (vzc >= VZC_VERTICAL_THRESH && vzc < VZC_GROUND_THRESH && vxc <= -VXC_WALL_MARGIN)
   71   1              {
   72   2                      return 1; // 平地上墙：vzc 1→0，vxc 0→-1
   73   2              }
   74   1              else if (vzc >= -1.0f && vzc <= VZC_VERTICAL_THRESH && vxc <= VXC_WALL_RELEASE)
   75   1              {
   76   2                      return 2; // 墙上天花板：vzc 0→-1，vxc -1→0
   77   2              }
   78   1              else if (vzc >= -1.0f && vzc <= VZC_VERTICAL_THRESH && vxc > VXC_WALL_RELEASE)
   79   1              {
   80   2                      return 3; // 天花板下墙：vzc -1→0，vxc 0→1
   81   2              }
   82   1              else if (vzc >= VZC_VERTICAL_THRESH && vzc < VZC_GROUND_THRESH && vxc > VXC_WALL_MARGIN)
   83   1              {
   84   2                      return 4; // 墙下平地：vzc 0→1，vxc 1→0
   85   2              }
   86   1              else
   87   1              {
   88   2                      return 0; // 默认回到平地段
   89   2              }
   90   1      }
   91          
   92          /**
   93           * @brief 计算场景强度系数（决定前向优待权重）
   94           * @param vzc 当前姿态的 Z 分量
   95           * @return 强度系数（0=不生效，1=完全生效）
   96           */
   97          static float get_scene_strength(float vzc)
   98          {
   99   1              if (func_abs(vzc) < VZC_VERTICAL_THRESH)
  100   1              {
  101   2                      return 1.0f; // 竖直墙面：完全生效
  102   2              }
  103   1              else if (vzc > VZC_VERTICAL_THRESH && vzc < VZC_GROUND_THRESH)
  104   1              {
  105   2                      // 正向缓坡面（下→左/右→下过渡）：强度随vzc增大而降低
  106   2                      return 1.0f - (vzc - VZC_VERTICAL_THRESH) / (VZC_GROUND_THRESH - VZC_VERTICAL_THRESH);
  107   2              }
  108   1              else if (vzc > VZC_INVERT_THRESH && vzc < -VZC_VERTICAL_THRESH)
  109   1              {
  110   2                      // 反向缓坡面（左→上/上→右过渡）：强度随vzc减小而降低
  111   2                      return 1.0f - (-VZC_VERTICAL_THRESH - vzc) / (-VZC_VERTICAL_THRESH - VZC_INVERT_THRESH);
  112   2              }
  113   1              else
  114   1              {
  115   2                      return 0.0f; // 平地/倒立顶点：不生效
  116   2              }
  117   1      }
  118          
  119          /**
  120           * @brief 计算前向优待修正值（在非平地场景提升“前向”吸附）
  121           * @param base_duty 当前阶段基础负压
  122           * @param vzc 当前姿态 Z 分量
  123           * @param vxc 当前姿态 X 分量（前向）
C251 COMPILER V5.60.0,  FUYA                                                               23/11/25  21:54:33  PAGE 3   

  124           * @param vyc 当前姿态 Y 分量（侧向）
  125           * @return 修正后的目标负压
  126           */
  127          static float calculate_forward_preference(float base_duty, float vzc, float vxc, float vyc)
  128          {
  129   1              // 1. 获取场景强度系数（0~1）
  130   1              float strength = get_scene_strength(vzc);
  131   1              float gt_norm;
  132   1              float align_fwd = 0.5f; // 默认中性
  133   1              float offset;
  134   1      
  135   1              if (strength < 0.1f)
  136   1              {
  137   2                      return base_duty; // 强度过低，不修正
  138   2              }
  139   1      
  140   1              // 2. 计算平面内方向模长（避免除零）
  141   1              gt_norm = (float)sqrt(vxc * vxc + vyc * vyc);
  142   1      
  143   1              // 3. 计算朝向对齐度（与x轴对齐：0=横向，1=前向）
  144   1              if (gt_norm > 1e-6f)
  145   1              {
  146   2                      align_fwd = (float)fabs(vxc) / gt_norm; // 兼容左右方向
  147   2                      align_fwd = func_limit_ab(align_fwd, 0.0f, 1.0f);
  148   2              }
  149   1      
  150   1              // 4. 计算前向优待偏移（横向-250，前向+250，基于PREFERENCE_OFFSET）
  151   1              offset = (align_fwd - 0.5f) * PREFERENCE_OFFSET;
  152   1      
  153   1              // 5. 按场景强度叠加偏移（强度越高，偏移影响越大）
  154   1              return base_duty + strength * offset;
  155   1      }
  156          
  157          /**
  158           * @brief 计算当前阶段的基础目标负压
  159           * @param phase 阶段编号
  160           * @param vzc 当前姿态
  161           * @return 基础目标负压
  162           */
  163          static float calculate_base_duty(uint8 phase, float vzc)
  164          {
  165   1              float ratio;
  166   1              float delta;
  167   1              DUTY_BOTTOM = fuya_xili;
  168   1      
  169   1              switch (phase)
  170   1              {
  171   2              case 0: // 平地
  172   2                      return DUTY_BOTTOM;
  173   2              case 1: // 平地上墙：vzc 1→0，指数型放大早期响应
  174   2                      ratio = 1.0f - vzc;
  175   2                      delta = 1.0f - (float)exp(-3.0f * ratio);
  176   2                      return DUTY_BOTTOM + (DUTY_LEFT - DUTY_BOTTOM) * func_limit_ab(delta, 0.0f, 1.0f);
  177   2              case 2: // 墙上天花板：vzc 0→-1
  178   2                      ratio = -vzc;
  179   2                      delta = 1.0f - (float)exp(-3.0f * ratio);
  180   2                      return DUTY_LEFT - (DUTY_LEFT - DUTY_TOP) * func_limit_ab(delta, 0.0f, 1.0f);
  181   2              case 3: // 天花板下墙：vzc -1→0
  182   2                      ratio = vzc + 1.0f;
  183   2                      delta = 1.0f - (float)exp(-3.0f * ratio);
  184   2                      return DUTY_TOP + (DUTY_RIGHT - DUTY_TOP) * func_limit_ab(delta, 0.0f, 1.0f);
  185   2              case 4: // 墙下平地：vzc 0→1
  186   2                      ratio = vzc;
  187   2                      delta = 1.0f - (float)exp(-3.0f * ratio);
  188   2                      return DUTY_RIGHT - (DUTY_RIGHT - DUTY_BOTTOM) * func_limit_ab(delta, 0.0f, 1.0f);
  189   2              default:
C251 COMPILER V5.60.0,  FUYA                                                               23/11/25  21:54:33  PAGE 4   

  190   2                      return 1800.0f;
  191   2              }
  192   1      }
  193          
  194          /**
  195           * @brief 根据阶段选择平滑系数 alpha
  196           * @param phase 阶段编号
  197           * @return alpha值（0~1）
  198           */
  199          static float get_alpha_by_phase(uint8 phase)
  200          {
  201   1              switch (phase)
  202   1              {
  203   2              case 0:
  204   2                      return ALPHA_UP1;
  205   2              case 1:
  206   2                      return ALPHA_UP2;
  207   2              case 2:
  208   2                      return ALPHA_DOWN1;
  209   2              case 3:
  210   2                      return ALPHA_DOWN2;
  211   2              default:
  212   2                      return ALPHA_DEFAULT;
  213   2              }
  214   1      }
  215          
  216          /**
  217           * @brief 简单版负压吸附占空比更新函数
  218           * @note 根据 IMU 解算得到的姿态向量，按五个阶段调节负压，并叠加前向优待：
  219           *       阶段 0：平地稳定段（vzc≈1，vxc≈0）
  220           *       阶段 1：平地 → 左墙（vzc:1→0，vxc:0→-1）
  221           *       阶段 2：左墙 → 天花板（vzc:0→-1，vxc:-1→0）
  222           *       阶段 3：天花板 → 右墙（vzc:-1→0，vxc:0→1）
  223           *       阶段 4：右墙 → 平地（vzc:0→1，vxc:1→0）
  224           *       同时根据前向优待策略，在非平地场景对目标负压做微调
  225           */
  226          void fuya_update_simple(void)
  227          {
  228   1              float vzc, vxc, vyc;
  229   1              float base_duty;
  230   1              float target_duty;
  231   1              float alpha;
  232   1      
  233   1              // 1. 传感器数据限幅（防异常）
  234   1              vzc = func_limit(vz, 1.0f);
  235   1              vxc = func_limit(vx, 1.0f);
  236   1              vyc = func_limit(vy, 1.0f);
  237   1      
  238   1              // 2. 判断当前阶段
  239   1              phase = get_current_phase(vz, vx);
  240   1      
  241   1              // 3. 计算阶段基础负压
  242   1              base_duty = calculate_base_duty(phase, vzc);
  243   1      
  244   1              // 4. 叠加前向优待（非平地场景差异化修正）
  245   1              target_duty = calculate_forward_preference(base_duty, vzc, vxc, vyc);
  246   1      
  247   1              // 6. 选择平滑系数（阶段差异化）
  248   1              alpha = get_alpha_by_phase(phase);
  249   1      
  250   1              // 7. 一阶低通滤波（平滑过渡，防突变）
  251   1              fuya_date = (int)(fuya_date + alpha * (target_duty - fuya_date));
  252   1      
  253   1              // 8. 保存目标占空比和当前vzc用于下一周期过渡判断
  254   1              fuya_date_factor = target_duty;
  255   1      
C251 COMPILER V5.60.0,  FUYA                                                               23/11/25  21:54:33  PAGE 5   

  256   1              // 9. 输出到风扇PWM
  257   1              fuya_motor_output(fuya_date);
  258   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2344     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        95     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        31     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
